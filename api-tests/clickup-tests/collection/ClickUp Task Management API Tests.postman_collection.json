{
	"info": {
		"_postman_id": "90b91a5a-01c9-4b55-9039-3e64b2359560",
		"name": "ClickUp Task Management API Tests",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "45512473"
	},
	"item": [
		{
			"name": "Authentication & Setup",
			"item": [
				{
					"name": "Verify Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200 - Token is valid\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// Extract and store test data for future API operations\r",
									"let jsonData = pm.response.json();\r",
									"if (jsonData.teams && jsonData.teams.length > 0) {\r",
									"    pm.environment.set(\"teamId\", jsonData.teams[0].id);\r",
									"    console.log(\"teamId saved:\", jsonData.teams[0].id);\r",
									"} else {\r",
									"    console.warn(\"No teamId found!\");\r",
									"}\r",
									"\r",
									"let firstUser = jsonData.teams[0].members[0].user;\r",
									"\r",
									"pm.environment.set(\"userId\", firstUser.id);\r",
									"console.log(\"User ID saved:\", firstUser.id);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/team",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"team"
							]
						}
					},
					"response": []
				},
				{
					"name": "Negative Test – No Authorization",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 - Authorization header required\", function () {\r",
									"   pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"pm.test(\"Response contains correct error message\", function () {\r",
									"   var jsonData = pm.response.json();\r",
									"   pm.expect(jsonData.err).to.eql(\"Authorization header required\");\r",
									"   pm.expect(jsonData.ECODE).to.eql(\"OAUTH_017\");\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/team",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"team"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Spaces",
			"item": [
				{
					"name": "Get List Spaces",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"\r",
									"// Extract and store test data for future API operations\r",
									"let spaces = pm.response.json().spaces;\r",
									"if (spaces && spaces.length > 0) {\r",
									"    pm.environment.set(\"spaceId\", spaces[0].id);\r",
									"    console.log(\"spaceId saved:\", spaces[0].id);\r",
									"} else {\r",
									"    console.warn(\"No spaces found!\");\r",
									"}\r",
									"\r",
									"pm.test(\"At least 1 Space exists\", function () {\r",
									"    pm.expect(spaces.length).to.be.above(0);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/team/{{teamId}}/space",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"team",
								"{{teamId}}",
								"space"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Space by ID",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"let responseData = pm.response.json();\r",
									"\r",
									"pm.test(\"Space has required fields\", function () {\r",
									"    pm.expect(responseData).to.have.property('id');\r",
									"    pm.expect(responseData).to.have.property('name');\r",
									"    pm.expect(responseData).to.have.property('private');\r",
									"    pm.expect(responseData).to.have.property('archived');\r",
									"    pm.expect(responseData).to.have.property('statuses');\r",
									"    pm.expect(responseData).to.have.property('features');\r",
									"});\r",
									"\r",
									"pm.test(\"Space ID matches requested ID\", function () {\r",
									"    const requestedId = pm.request.url.path[3]; \r",
									"    pm.expect(responseData.id).to.eql(requestedId);\r",
									"});\r",
									"\r",
									"pm.test(\"Space is not archived\", function () {\r",
									"    pm.expect(responseData.archived).to.be.false;\r",
									"});\r",
									"\r",
									"pm.test(\"Space features are properly configured\", function () {\r",
									"    pm.expect(responseData.features).to.be.an('object');\r",
									"    pm.expect(responseData.features).to.have.property('due_dates');\r",
									"    pm.expect(responseData.features).to.have.property('time_tracking');\r",
									"    pm.expect(responseData.features).to.have.property('priorities');\r",
									"});\r",
									"\r",
									"pm.test(\"Space has valid name and ID format\", function () {\r",
									"    pm.expect(responseData.name).to.be.a('string').and.not.empty;\r",
									"    pm.expect(responseData.id).to.be.a('string').and.match(/^\\d+$/);\r",
									"});\r",
									"\r",
									"\r",
									"pm.environment.set(\"spaceId\", responseData.id);\r",
									"pm.environment.set(\"spaceName\", responseData.name);\r",
									"pm.environment.set(\"spacePrivate\", responseData.private.toString());\r",
									"\r",
									"pm.test(\"Environment variables saved successfully\", function () {\r",
									"    pm.expect(pm.environment.get(\"spaceName\")).to.eql(responseData.name);\r",
									"    pm.expect(pm.environment.get(\"spaceId\")).to.eql(responseData.id);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/space/{{spaceId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"space",
								"{{spaceId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Space",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let randomName = pm.variables.replaceIn(\"{{$randomCompanyName}}\");\r",
									"pm.environment.set(\"updatedSpaceName\", randomName);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"let responseData = pm.response.json();\r",
									"\r",
									"pm.test(\"Space name matches the generated random name\", function () {\r",
									"    pm.expect(responseData.name).to.eql(pm.environment.get(\"updatedSpaceName\"));\r",
									"});\r",
									"\r",
									"pm.test(\"Space ID remains unchanged after update\", function () {\r",
									"    pm.expect(responseData.id).to.eql(pm.environment.get(\"spaceId\"));\r",
									"});\r",
									"\r",
									"pm.test(\"Space configuration preserved after name update\", function () {\r",
									"    pm.expect(responseData.private).to.be.false;\r",
									"    pm.expect(responseData.archived).to.be.false;\r",
									"    pm.expect(responseData.statuses).to.be.an('array').and.not.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Name update was successful and different from original\", function () {\r",
									"    const originalName = pm.environment.get(\"spaceName\");\r",
									"    pm.expect(responseData.name).to.not.eql(originalName);\r",
									"    pm.expect(responseData.name).to.be.a('string').and.not.empty;\r",
									"});\r",
									"\r",
									"pm.environment.set(\"spaceName\", responseData.name);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{updatedSpaceName}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/space/{{spaceId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"space",
								"{{spaceId}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Folders",
			"item": [
				{
					"name": "Create Folder",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let randomFolderName = pm.variables.replaceIn(\"{{$randomLoremWord}}\");\r",
									"pm.environment.set(\"folderName\", randomFolderName);\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"eval(pm.collectionVariables.get(\"validateClickUpFolder\"));\r",
									"eval(pm.collectionVariables.get(\"validateFolderDataMatch\"));\r",
									"eval(pm.collectionVariables.get(\"logFolderResults\"));\r",
									"eval(pm.collectionVariables.get(\"updateFolderVariables\"));\r",
									"\r",
									"validateBasicResponse();\r",
									"const responseJson = pm.response.json();\r",
									"validateClickUpFolder(responseJson);\r",
									"const expectedName = pm.environment.get(\"folderName\");\r",
									"validateFolderDataMatch(responseJson, expectedName);\r",
									"\r",
									"pm.test(\"Folder created with unique ID\", function () {\r",
									"    pm.expect(responseJson.id).to.not.eql(pm.collectionVariables.get(\"lastFolderId\"));\r",
									"});\r",
									"\r",
									"pm.test(\"Created folder is not deleted by default\", function () {\r",
									"    if (responseJson.hasOwnProperty('deleted')) {\r",
									"        pm.expect(responseJson.deleted).to.be.false;\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.environment.set(\"folderId\", responseJson.id);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{folderName}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/space/{{spaceId}}/folder",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"space",
								"{{spaceId}}",
								"folder"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Folder for Deletion",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let randomFolderName = pm.variables.replaceIn(\"{{$randomWord}}\");\r",
									"pm.environment.set(\"deletedFolderName\", randomFolderName);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"eval(pm.collectionVariables.get(\"validateClickUpFolder\"));\r",
									"eval(pm.collectionVariables.get(\"validateFolderDataMatch\"));\r",
									"eval(pm.collectionVariables.get(\"logFolderResults\"));\r",
									"eval(pm.collectionVariables.get(\"updateFolderVariables\"));\r",
									"\r",
									"validateBasicResponse();\r",
									"const responseJson = pm.response.json();\r",
									"validateClickUpFolder(responseJson);\r",
									"\r",
									"const expectedName = pm.environment.get(\"deletedFolderName\");\r",
									"validateFolderDataMatch(responseJson, expectedName);\r",
									"\r",
									"pm.test(\"Prerequisites exist for folder comparison\", function () {\r",
									"    const mainFolderId = pm.environment.get(\"folderId\");\r",
									"    const mainFolderName = pm.environment.get(\"folderName\");\r",
									"    \r",
									"    pm.expect(mainFolderId, \"Main folder ID must exist for comparison\").to.exist;\r",
									"    pm.expect(mainFolderId, \"Main folder ID cannot be empty\").to.not.be.empty;\r",
									"    pm.expect(mainFolderName, \"Main folder name must exist for comparison\").to.exist;\r",
									"    pm.expect(mainFolderName, \"Main folder name cannot be empty\").to.not.be.empty;\r",
									"});\r",
									"\r",
									"pm.test(\"Deletion folder has different ID than main folder\", function () {\r",
									"    const mainFolderId = pm.environment.get(\"folderId\");\r",
									"    pm.expect(responseJson.id, \"Deletion folder must have different ID than main folder\").to.not.eql(mainFolderId);\r",
									"});\r",
									"\r",
									"pm.test(\"Deletion folder name differs from main folder\", function () {\r",
									"    const mainFolderName = pm.environment.get(\"folderName\");\r",
									"    pm.expect(responseJson.name, \"Deletion folder must have different name than main folder\").to.not.eql(mainFolderName);\r",
									"});\r",
									"\r",
									"pm.environment.set(\"deletedFolderId\", responseJson.id);\r",
									"\r",
									"logFolderResults(\"CREATE\", responseJson, \"deletion folder\");\r",
									"updateFolderVariables(responseJson, \"CREATE_FOR_DELETION\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{deletedFolderName}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/space/{{spaceId}}/folder",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"space",
								"{{spaceId}}",
								"folder"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Folder by ID",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"eval(pm.collectionVariables.get(\"validateClickUpFolder\"));\r",
									"eval(pm.collectionVariables.get(\"logFolderResults\"));\r",
									"\r",
									"validateBasicResponse();\r",
									"const responseJson = pm.response.json();\r",
									"\r",
									"pm.test(\"Retrieved folder matches requested folder ID\", function () {\r",
									"    const expectedId = pm.environment.get(\"folderId\");\r",
									"    pm.expect(expectedId, \"folderId environment variable must exist\").to.exist;\r",
									"    pm.expect(responseJson.id, \"Response must return the requested folder\").to.eql(expectedId);\r",
									"});\r",
									"\r",
									"validateClickUpFolder(responseJson);\r",
									"\r",
									"logFolderResults(\"GET\", responseJson);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/folder/{{folderId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"folder",
								"{{folderId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Folder Name",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let updatedFolderName = pm.variables.replaceIn(\"{{$randomWord}}\");\r",
									"pm.environment.set(\"updatedFolderName\", updatedFolderName);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"eval(pm.collectionVariables.get(\"validateClickUpFolder\"));\r",
									"eval(pm.collectionVariables.get(\"logFolderResults\"));\r",
									"eval(pm.collectionVariables.get(\"updateFolderVariables\"));\r",
									"\r",
									"validateBasicResponse();\r",
									"const responseJson = pm.response.json();\r",
									"\r",
									"pm.test(\"Prerequisites for update validation exist\", function () {\r",
									"    const expectedId = pm.environment.get(\"folderId\");\r",
									"    const updatedName = pm.environment.get(\"updatedFolderName\");\r",
									"    const originalName = pm.environment.get(\"folderName\");\r",
									"    \r",
									"    pm.expect(expectedId, \"folderId must be set\").to.exist;\r",
									"    pm.expect(updatedName, \"updatedFolderName must be set\").to.exist;\r",
									"    pm.expect(originalName, \"original folderName must be set\").to.exist;\r",
									"});\r",
									"\r",
									"pm.test(\"Folder ID remains unchanged after update\", function () {\r",
									"    const expectedId = pm.environment.get(\"folderId\");\r",
									"    pm.expect(responseJson.id, \"ID should never change during update\").to.eql(expectedId);\r",
									"});\r",
									"\r",
									"pm.test(\"Folder name was actually updated\", function () {\r",
									"    const updatedName = pm.environment.get(\"updatedFolderName\");\r",
									"    const originalName = pm.environment.get(\"folderName\");\r",
									"    \r",
									"    pm.expect(responseJson.name, \"Response should contain the updated name\").to.eql(updatedName);\r",
									"    pm.expect(responseJson.name, \"Name should be different from original\").to.not.eql(originalName);\r",
									"    pm.expect(updatedName, \"Updated name should be different from original\").to.not.eql(originalName);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{updatedFolderName}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/folder/{{folderId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"folder",
								"{{folderId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Folder",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"DELETE operation prerequisites and basic validation\", function () {\r",
									"    const deletedId = pm.environment.get(\"deletedFolderId\");\r",
									"    \r",
									"    pm.expect(deletedId, \"deletedFolderId must be set before deletion\").to.exist;\r",
									"    pm.expect(deletedId, \"deletedFolderId cannot be empty\").to.not.be.empty;\r",
									"    \r",
									"    pm.expect([200, 202, 204], \"DELETE should return success status\").to.include(pm.response.code);\r",
									"    \r",
									"    pm.expect(pm.response.responseTime, \"DELETE should complete within 2 seconds\").to.be.below(2000);\r",
									"    pm.expect(pm.response.responseTime, \"Response time should be positive\").to.be.above(0);\r",
									"    \r",
									"    console.log(`DELETE completed (${pm.response.code}) in ${pm.response.responseTime}ms`);\r",
									"});\r",
									"\r",
									"pm.test(\"DELETE response body validation\", function () {\r",
									"    const statusCode = pm.response.code;\r",
									"    const responseText = pm.response.text();\r",
									"\r",
									"    if (statusCode === 204) {\r",
									"        pm.expect(responseText, \"204 No Content should have empty body\").to.be.empty;\r",
									"        console.log(\"✓ 204 No Content - correct empty response\");\r",
									"        \r",
									"    } else if (statusCode === 200 || statusCode === 202) {\r",
									"        pm.expect(responseText, \"200/202 must have response body\").to.not.be.empty;\r",
									"        \r",
									"        let responseJson;\r",
									"        pm.expect(() => {\r",
									"            responseJson = JSON.parse(responseText);\r",
									"        }, \"Response body must be valid JSON\").to.not.throw();\r",
									"        \r",
									"        pm.expect(responseJson, \"Response must be an object\").to.be.an('object');\r",
									"        \r",
									"        if (responseJson.hasOwnProperty('id')) {\r",
									"            const deletedId = pm.environment.get(\"deletedFolderId\");\r",
									"            pm.expect(responseJson.id, \"Response ID must match deleted folder\").to.eql(deletedId);\r",
									"        }\r",
									"        \r",
									"        \r",
									"    } else {\r",
									"        pm.expect.fail(`Unexpected status code ${statusCode} - should be 200, 202, or 204`);\r",
									"    }\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/folder/{{deletedFolderId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"folder",
								"{{deletedFolderId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Folder Deletion Verification",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"DELETE verification - prerequisites and basic validation\", function () {\r",
									"    const deletedId = pm.environment.get(\"deletedFolderId\");\r",
									"    pm.expect(deletedId, \"deletedFolderId must exist for verification\").to.exist;\r",
									"    pm.expect([200, 404], \"Status should be 200 (soft delete) or 404 (hard delete)\").to.include(pm.response.code);\r",
									"    pm.expect(pm.response.responseTime, \"Response should be fast\").to.be.below(2000);\r",
									"});\r",
									"\r",
									"if (pm.response.code === 200) {\r",
									"    pm.test(\"SOFT DELETE - core validations\", function () {\r",
									"        const responseJson = pm.response.json();\r",
									"        const deletedId = pm.environment.get(\"deletedFolderId\");\r",
									"        const originalSpaceId = pm.environment.get(\"spaceId\");\r",
									"        \r",
									"        pm.expect(originalSpaceId, \"originalSpaceId must exist for validation\").to.exist;\r",
									"        \r",
									"        pm.expect(pm.response.headers.get('Content-Type'), \"200 response should be JSON\").to.include('application/json');\r",
									"        \r",
									"        pm.expect(responseJson, \"Response should have deleted field\").to.have.property('deleted');\r",
									"        pm.expect(responseJson.deleted, \"Folder should be marked as deleted\").to.be.true;\r",
									"        pm.expect(responseJson.id, \"ID should match deleted folder\").to.eql(deletedId);\r",
									"        \r",
									"        pm.expect(responseJson.name, \"Name should be preserved\").to.be.a('string').and.not.empty;\r",
									"        pm.expect(responseJson.space, \"Space info should be preserved\").to.exist;\r",
									"        pm.expect(responseJson.space.id, \"Space ID should be preserved\").to.be.a('string');\r",
									"        pm.expect(responseJson.space.id, \"Space ID should match original\").to.eql(originalSpaceId);\r",
									"        \r",
									"    \r",
									"    });\r",
									"    \r",
									"    const responseJson = pm.response.json();\r",
									"    \r",
									"    if (responseJson.hasOwnProperty('task_count')) {\r",
									"        pm.test(\"SOFT DELETE - task count should be zero\", function () {\r",
									"            const responseJson = pm.response.json();\r",
									"            pm.expect(responseJson.task_count, \"Task count should be 0 after deletion\").to.eql(\"0\");\r",
									"        });\r",
									"    }\r",
									"    \r",
									"    if (responseJson.hasOwnProperty('lists')) {\r",
									"        pm.test(\"SOFT DELETE - lists should be empty\", function () {\r",
									"            const responseJson = pm.response.json();\r",
									"            pm.expect(responseJson.lists, \"Lists should be empty after deletion\").to.be.an('array').and.be.empty;\r",
									"        });\r",
									"    }\r",
									"}\r",
									"\r",
									"pm.test(\"SOFT DELETE - required fields validation\", function () {\r",
									"    const responseJson = pm.response.json();\r",
									"    \r",
									"    const requiredFields = ['id', 'name', 'deleted', 'space'];\r",
									"    requiredFields.forEach(field => {\r",
									"        pm.expect(responseJson, `Should have ${field} field`).to.have.property(field);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/folder/{{deletedFolderId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"folder",
								"{{deletedFolderId}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Lists",
			"item": [
				{
					"name": "Get Templates",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json(); \r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"pm.test('Response has templates array', function () {\r",
									"    pm.expect(response).to.have.property('templates');\r",
									"    pm.expect(response.templates).to.be.an('array');\r",
									"});\r",
									"\r",
									"pm.test('Templates have valid structure', function () {\r",
									"    if (response.templates && response.templates.length > 0) {\r",
									"        response.templates.forEach((template, index) => {\r",
									"            pm.expect(template, `Template ${index} should be an object`).to.be.an('object');\r",
									"            pm.expect(template, `Template ${index} should have id`).to.have.property('id');\r",
									"            pm.expect(template, `Template ${index} should have name`).to.have.property('name');\r",
									"            pm.expect(template.id, `Template ${index} id should be non-empty string`).to.be.a('string').and.not.empty;\r",
									"            pm.expect(template.name, `Template ${index} name should be non-empty string`).to.be.a('string').and.not.empty;\r",
									"        \r",
									"            pm.expect(template.id, `Template ${index} id should not contain spaces`).to.not.match(/\\s/);\r",
									"        });\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test('Store template data', function () {\r",
									"    if (response.templates.length > 0) {\r",
									"        const firstTemplate = response.templates[0];\r",
									"        pm.environment.set(\"templateId\", firstTemplate.id);\r",
									"        pm.environment.set(\"templateName\", firstTemplate.name);\r",
									"        pm.environment.set(\"templatesAvailable\", \"true\");\r",
									"        \r",
									"        console.log(`Found ${response.templates.length} templates`);\r",
									"        response.templates.forEach((t, i) => console.log(`${i+1}. ${t.name}`));\r",
									"    } else {\r",
									"        pm.environment.set(\"templatesAvailable\", \"false\");\r",
									"        console.warn('No templates available');\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"protocolProfileBehavior": {
						"disableBodyPruning": true
					},
					"request": {
						"method": "GET",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/team/{{teamId}}/list_template",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"team",
								"{{teamId}}",
								"list_template"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create List From Template",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const templateName = pm.environment.get(\"templateName\") \r",
									"const timestamp = Date.now();\r",
									"const randomWord = pm.variables.replaceIn(\"{{$randomWord}}\");\r",
									"const listName = `Template List ${randomWord}_${timestamp}`;\r",
									"\r",
									"pm.environment.set(\"template_list_name\", listName);\r",
									"pm.environment.set(\"template_list_description\", `List created from template on ${new Date().toISOString()}`);\r",
									"\r",
									"pm.environment.set(\"template_list_status\", pm.environment.get(\"template_list_status\") || \"active\");\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"const responseJson = pm.response.json();\r",
									"\r",
									"pm.test(\"Template prerequisites validation\", function () {\r",
									"    const templateId = pm.environment.get(\"templateId\");\r",
									"    const templateName = pm.environment.get(\"templateName\");\r",
									"    \r",
									"    pm.expect(templateId, \"templateId should exist from previous request\").to.exist;\r",
									"    pm.expect(templateName, \"templateName should exist from previous request\").to.exist;\r",
									"});\r",
									"\r",
									"pm.test(\"Response has expected structure for list creation\", function () {\r",
									"    const hasListInResponse = responseJson.hasOwnProperty('list');\r",
									"    const isDirectListResponse = responseJson.hasOwnProperty('id') && responseJson.hasOwnProperty('name');\r",
									"    \r",
									"    const isValidStructure = hasListInResponse || isDirectListResponse;\r",
									"    \r",
									"    pm.expect(isValidStructure, \r",
									"        \"Response should contain either 'list' object or be a direct list response with id and name\"\r",
									"    ).to.be.true;\r",
									"    \r",
									"});\r",
									"\r",
									"pm.test(\"Created list has required properties\", function () {\r",
									"    const listData = responseJson.list || responseJson;\r",
									"    \r",
									"    pm.expect(listData, \"List data should exist\").to.exist;\r",
									"    pm.expect(listData.id, \"List ID should be non-empty string\").to.be.a('string').and.not.empty;\r",
									"\r",
									"    pm.environment.set(\"template_list_id\", listData.id);\r",
									"});\r",
									"\r",
									"pm.test(\"List properties match template request\", function () {\r",
									"    const listData = responseJson.list || responseJson;\r",
									"    const expectedName = pm.environment.get(\"template_list_name\");\r",
									" \r",
									"    pm.expect(listData, \"Response should contain name field\").to.have.property('name');\r",
									"    \r",
									"    pm.expect(listData.name, \"List name should match sent data\").to.equal(expectedName);\r",
									"});\r",
									"    \r",
									"\r",
									"\r",
									"pm.test(\"Handle potential API inconsistencies\", function () {\r",
									"\r",
									"    if (responseJson.error || responseJson.message) {\r",
									"        pm.expect.fail(`API returned error: ${responseJson.error || responseJson.message}`);\r",
									"    }\r",
									"\r",
									"    const unexpectedErrorFields = ['errors', 'failure', 'exception'];\r",
									"    unexpectedErrorFields.forEach(field => {\r",
									"        if (responseJson.hasOwnProperty(field)) {\r",
									"            console.warn(`Unexpected field '${field}' in response:`, responseJson[field]);\r",
									"        }\r",
									"    });\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{template_list_name}}\",\r\n  \"description\": \"{{template_list_description}}\",\r\n  \"status\": \"{{template_list_status}}\",\r\n  \"content\": \"List created from template: {{templateName}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/folder/{{folderId}}/list_template/{{templateId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"folder",
								"{{folderId}}",
								"list_template",
								"{{templateId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Additional List",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const timestamp = Date.now();\r",
									"const randomWord = pm.variables.replaceIn(\"{{$randomWord}}\");\r",
									"const additionalListName = `Additional List ${randomWord}_${timestamp}`;\r",
									"\r",
									"pm.environment.set(\"additionalListName\", additionalListName);\r",
									"pm.environment.set(\"additionalListContent\", \"Additional list for Multi-List testing and bulk operations verification\");\r",
									"\r",
									"const tomorrow = new Date();\r",
									"tomorrow.setDate(tomorrow.getDate() + 1);\r",
									"\r",
									"const nextWeek = new Date();\r",
									"nextWeek.setDate(nextWeek.getDate() + 7);\r",
									"\r",
									"pm.environment.set(\"additionalListStartDate\", tomorrow.getTime().toString());\r",
									"pm.environment.set(\"additionalListDueDate\", nextWeek.getTime().toString());\r",
									"\r",
									"const differentPriority = Math.floor(Math.random() * 2) + 3; \r",
									"pm.environment.set(\"additionalListPriority\", differentPriority.toString());"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"eval(pm.collectionVariables.get(\"validateClickUpList\"));\r",
									"\r",
									"validateBasicResponse();\r",
									"const responseJson = pm.response.json();\r",
									"validateClickUpList(responseJson);\r",
									"\r",
									"\r",
									"pm.test(\"List name is unique and matches expected pattern\", () => {\r",
									"    const expectedName = pm.environment.get(\"additionalListName\");\r",
									"    pm.expect(responseJson.name).to.eql(expectedName);\r",
									"    pm.expect(responseJson.name).to.include('Additional List');\r",
									"    pm.expect(responseJson.name).to.include('_'); \r",
									"});\r",
									"\r",
									"pm.test(\"List content is correctly set\", () => {\r",
									"    pm.expect(responseJson.content).to.include(\"Multi-List testing\");\r",
									"    pm.expect(responseJson.content).to.include(\"bulk operations\");\r",
									"});\r",
									"\r",
									"pm.test(\"List dates are set correctly and logically\", () => {\r",
									"    const startDate = parseInt(responseJson.start_date);\r",
									"    const dueDate = parseInt(responseJson.due_date);\r",
									"    const now = Date.now();\r",
									"    \r",
									"    pm.expect(startDate).to.be.greaterThan(now);\r",
									"    pm.expect(dueDate).to.be.greaterThan(startDate);\r",
									"    pm.expect(dueDate - startDate).to.be.approximately(6 * 24 * 60 * 60 * 1000, 1000); \r",
									"});\r",
									"\r",
									"\r",
									"pm.test(\"Inbound address follows correct pattern and is unique\", () => {\r",
									"    const firstListId = pm.environment.get(\"folderlessListId\");\r",
									"    const thisListId = responseJson.id;\r",
									"    \r",
									"    pm.expect(thisListId).to.not.equal(firstListId);\r",
									"    pm.expect(responseJson.inbound_address).to.include(thisListId);\r",
									"    pm.expect(responseJson.inbound_address).to.match(/^a\\.t\\.\\d+\\.u-\\d+\\.[a-f0-9-]+@tasks\\.clickup\\.com$/);\r",
									"});\r",
									"\r",
									"pm.test(\"Store list ID for multi-list testing\", () => {\r",
									"    pm.environment.set(\"additional_list_id\", responseJson.id);\r",
									"    \r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{additionalListName}}\",\r\n  \"description\": \"Secondary list created for multi-list operations testing\",\r\n  \"due_date\": {{additionalListDueDate}},\r\n  \"due_date_time\": false,\r\n  \"priority\": {{additionalListPriority}},\r\n  \"assignee\": {{userId}},\r\n  \"start_date\": {{additionalListStartDate}},\r\n  \"start_date_time\": false,\r\n  \"content\": \"{{additionalListContent}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/folder/{{folderId}}/list",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"folder",
								"{{folderId}}",
								"list"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Folderless List",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let randomListName = pm.variables.replaceIn(\"{{$randomLoremWords}}\") + \"_folderless\";\r",
									"let listDescription = pm.variables.replaceIn(\"{{$randomLoremParagraph}}\") + \" - This is a comprehensive test list for folderless functionality with detailed description containing special characters: @#$%^&*()_+ and unicode: ñáéíóú\";\r",
									"\r",
									"pm.environment.set(\"folderlessListName\", randomListName);\r",
									"pm.environment.set(\"listDescription\", listDescription);\r",
									"\r",
									"let startDate = new Date();\r",
									"startDate.setDate(startDate.getDate() + 2);\r",
									"let dueDate = new Date();\r",
									"dueDate.setDate(dueDate.getDate() + 7);\r",
									"\r",
									"pm.environment.set(\"listStartDate\", startDate.getTime().toString());\r",
									"pm.environment.set(\"listDueDate\", dueDate.getTime().toString());\r",
									"\r",
									"let priority = Math.floor(Math.random() * 4) + 1;\r",
									"pm.environment.set(\"listPriority\", priority.toString());\r",
									"\r",
									"const statusColorMap = {\r",
									"    \"red\": \"#d33d44\",\r",
									"    \"orange\": \"#e16b16\", \r",
									"    \"yellow\": \"#f8ae00\",\r",
									"    \"green\": \"#6fcf2f\", \r",
									"    \"blue\": \"#2d9cdb\",\r",
									"    \"purple\": \"#9b51e0\",\r",
									"    \"pink\": \"#ee5e99\"\r",
									"};\r",
									"\r",
									"let statuses = Object.keys(statusColorMap);\r",
									"let randomStatus = statuses[Math.floor(Math.random() * statuses.length)];\r",
									"pm.environment.set(\"listStatus\", randomStatus);\r",
									"pm.environment.set(\"expectedStatusColor\", statusColorMap[randomStatus]);\r",
									"\r",
									"let assignee = pm.environment.get(\"userId\");\r",
									"pm.environment.set(\"assigneeId\", assignee);\r",
									"\r",
									"let content = \"Detailed test content for folderless list: \" + pm.variables.replaceIn(\"{{$randomLoremSentence}}\") + \" with timestamp: \" + Date.now();\r",
									"pm.environment.set(\"listContent\", content);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"eval(pm.collectionVariables.get(\"validateClickUpList\"));\r",
									"\r",
									"validateBasicResponse();\r",
									"const responseJson = pm.response.json();\r",
									"validateClickUpList(responseJson);\r",
									"\r",
									"pm.test(\"List name matches sent data\", function () {\r",
									"    pm.expect(responseJson.name).to.eql(pm.environment.get(\"folderlessListName\"));\r",
									"});\r",
									"\r",
									"pm.test(\"List description contains special characters\", function () {\r",
									"    if (responseJson.description) {\r",
									"        pm.expect(responseJson.description).to.include(\"@#$%\");\r",
									"        pm.expect(responseJson.description).to.include(\"ñáéíóú\");\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Start date is correctly set\", function () {\r",
									"    const expectedStartDate = parseInt(pm.environment.get(\"listStartDate\"));\r",
									"    const actualStartDate = parseInt(responseJson.start_date);\r",
									"    \r",
									"});\r",
									"\r",
									"pm.test(\"Due date is correctly set\", function () {\r",
									"    const expectedDueDate = parseInt(pm.environment.get(\"listDueDate\"));\r",
									"    const actualDueDate = parseInt(responseJson.due_date);\r",
									"    \r",
									"    pm.expect(actualDueDate).to.equal(expectedDueDate);\r",
									"    pm.expect(new Date(actualDueDate) > new Date(parseInt(pm.environment.get(\"listStartDate\")))).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Priority is correctly set\", function () {\r",
									"    const expectedPriority = pm.environment.get(\"listPriority\");\r",
									"    const actualPriority = responseJson.priority.priority;\r",
									"    \r",
									"    const priorityMap = {\r",
									"        \"1\": \"urgent\",\r",
									"        \"2\": \"high\", \r",
									"        \"3\": \"normal\",\r",
									"        \"4\": \"low\"\r",
									"    };\r",
									"    \r",
									"    pm.expect(actualPriority).to.equal(priorityMap[expectedPriority]);\r",
									"});\r",
									"\r",
									"pm.test(\"Status is correctly set\", function () {\r",
									"    const expectedStatus = pm.environment.get(\"listStatus\");\r",
									"    const actualStatus = responseJson.status.status;\r",
									"    \r",
									"    pm.expect(actualStatus).to.equal(expectedStatus);\r",
									"});\r",
									"\r",
									"pm.test(\"Assignee is correctly set\", function () {\r",
									"    const expectedAssignee = pm.environment.get(\"assigneeId\");\r",
									"    const actualAssignee = responseJson.assignee.id;\r",
									"    \r",
									"    pm.expect(actualAssignee.toString()).to.equal(expectedAssignee.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"Content is correctly set\", function () {\r",
									"    const expectedContent = pm.environment.get(\"listContent\");\r",
									"    \r",
									"    if (responseJson.content) {\r",
									"        pm.expect(responseJson.content).to.include(\"Detailed test content for folderless list\");\r",
									"        pm.expect(responseJson.content.length).to.be.greaterThan(20);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Store ClickUp's actual color mapping for future reference\", function () {\r",
									"    if (responseJson.status && responseJson.status.color) {\r",
									"        const actualStatus = responseJson.status.status;\r",
									"        const actualColor = responseJson.status.color;\r",
									"        \r",
									"        const colorMap = JSON.parse(pm.environment.get(\"clickUpColorMap\") || \"{}\");\r",
									"        colorMap[actualStatus] = actualColor;\r",
									"        \r",
									"        pm.environment.set(\"clickUpColorMap\", JSON.stringify(colorMap));\r",
									"    \r",
									"    }\r",
									"});\r",
									"pm.test(\"List has required structure\", function () {\r",
									"    pm.expect(responseJson).to.have.property('id');\r",
									"    pm.expect(responseJson).to.have.property('space');\r",
									"    pm.expect(responseJson).to.have.property('folder');\r",
									"    pm.expect(responseJson).to.have.property('task_count');\r",
									"    pm.expect(responseJson.task_count).to.equal(0); \r",
									"});\r",
									"\r",
									"pm.test(\"Folder is hidden (folderless list characteristic)\", function () {\r",
									"    pm.expect(responseJson.folder.hidden).to.be.true;\r",
									"    pm.expect(responseJson.folder.name).to.equal(\"hidden\");\r",
									"});\r",
									"\r",
									"pm.test(\"Space access is granted\", function () {\r",
									"    pm.expect(responseJson.space.access).to.be.true;\r",
									"});\r",
									"\r",
									"pm.test(\"Statuses array is properly configured\", function () {\r",
									"    pm.expect(responseJson.statuses).to.be.an('array');\r",
									"    pm.expect(responseJson.statuses.length).to.be.greaterThan(0);\r",
									"    \r",
									"    const statusTypes = responseJson.statuses.map(s => s.type);\r",
									"    pm.expect(statusTypes).to.include('open');\r",
									"    pm.expect(statusTypes).to.include('closed');\r",
									"});\r",
									"\r",
									"pm.test(\"Inbound email address is generated\", function () {\r",
									"    pm.expect(responseJson.inbound_address).to.include('@tasks.clickup.com');\r",
									"    pm.expect(responseJson.inbound_address).to.include(responseJson.id);\r",
									"});\r",
									"\r",
									"pm.test(\"List is not archived initially\", function () {\r",
									"    pm.expect(responseJson.archived).to.be.false;\r",
									"});\r",
									"\r",
									"pm.test(\"Order index is set to 0 for new list\", function () {\r",
									"    pm.expect(responseJson.orderindex).to.equal(0);\r",
									"});\r",
									"\r",
									"pm.test(\"Store list ID for future operations\", function () {\r",
									"    if (responseJson.id) {\r",
									"        pm.environment.set(\"folderlessListId\", responseJson.id);\r",
									"        pm.environment.set(\"lastCreatedListId\", responseJson.id);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Business rule: Due date after start date\", function () {\r",
									"    const startDate = parseInt(responseJson.start_date);\r",
									"    const dueDate = parseInt(responseJson.due_date);\r",
									"    pm.expect(dueDate).to.be.greaterThan(startDate);\r",
									"});\r",
									"\r",
									"pm.test(\"UTF-8 characters are preserved\", function () {\r",
									"    if (responseJson.name) {\r",
									"        pm.expect(responseJson.name).to.match(/[a-zA-Z0-9_ñáéíóú]/);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Inbound email follows correct pattern\", function () {\r",
									"    const emailPattern = /^a\\.t\\.\\d+\\.u-\\d+\\.[a-f0-9-]+@tasks\\.clickup\\.com$/;\r",
									"    pm.expect(responseJson.inbound_address).to.match(emailPattern);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{folderlessListName}}\",\r\n  \"description\": \"{{listDescription}}\",\r\n  \"due_date\": {{listDueDate}},\r\n  \"priority\": {{listPriority}},\r\n  \"assignee\": {{assigneeId}},\r\n  \"status\": \"{{listStatus}}\",\r\n  \"start_date\": {{listStartDate}},\r\n  \"color\": \"{{listColor}}\",\r\n  \"content\": \"{{listContent}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/space/{{spaceId}}/list",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"space",
								"{{spaceId}}",
								"list"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Folderless Lists",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"\r",
									"pm.test(\"API returns lists successfully\", function () {\r",
									"    pm.expect(pm.response.code).to.equal(200);\r",
									"    pm.expect(responseJson.lists).to.be.an('array');\r",
									"    console.log(`Found ${responseJson.lists.length} lists`);\r",
									"});\r",
									"\r",
									"pm.test(\"Space contains folderless lists\", function () {\r",
									"    const folderlessLists = responseJson.lists.filter(list => \r",
									"        list.folder && list.folder.hidden === true\r",
									"    );\r",
									"    \r",
									"    pm.expect(folderlessLists.length).to.be.above(0);\r",
									"    console.log(`Folderless lists: ${folderlessLists.length}`);\r",
									"    \r",
									"    if (folderlessLists.length > 0) {\r",
									"        pm.collectionVariables.set(\"testListId\", folderlessLists[0].id);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Lists have essential data\", function () {\r",
									"    responseJson.lists.forEach(list => {\r",
									"        pm.expect(list.id, \"List must have ID\").to.exist.and.not.be.empty;\r",
									"        pm.expect(list.name, \"List must have name\").to.exist.and.not.be.empty;\r",
									"        pm.expect(list.folder, \"List must belong to folder\").to.exist;\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Response time acceptable\", function () {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(3000);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/space/{{spaceId}}/list",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"space",
								"{{spaceId}}",
								"list"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Folderless List",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let updatedListName = \"UPDATED_\" + pm.variables.replaceIn(\"{{$randomWord}}\") + \"_folderless_\" + Date.now();\r",
									"let updatedDescription = \"UPDATED: \" + pm.variables.replaceIn(\"{{$randomLoremParagraph}}\") + \" Special: ∑∆∫∂π√∞ at \" + new Date().toISOString();\r",
									"\r",
									"pm.environment.set(\"updatedFolderlessListName\", updatedListName);\r",
									"pm.environment.set(\"updatedListDescription\", updatedDescription);\r",
									"\r",
									"let updatedDueDate = new Date();\r",
									"updatedDueDate.setDate(updatedDueDate.getDate() + 14);\r",
									"pm.environment.set(\"updatedListDueDate\", updatedDueDate.getTime().toString());\r",
									"\r",
									"let originalPriority = parseInt(pm.environment.get(\"listPriority\")) || 3;\r",
									"let updatedPriority = originalPriority === 1 ? 4 : 1;\r",
									"pm.environment.set(\"updatedListPriority\", updatedPriority.toString());\r",
									"\r",
									"let updatedStatus = \"green\";\r",
									"let updatedColor = \"#00FF00\";\r",
									"pm.environment.set(\"updatedListStatus\", updatedStatus);\r",
									"pm.environment.set(\"updatedListColor\", updatedColor);\r",
									"\r",
									"let updatedContent = \"UPDATED CONTENT: \" + pm.variables.replaceIn(\"{{$randomLoremSentence}}\") + \" emoji: 🔄📝✅ timestamp: \" + Date.now();\r",
									"pm.environment.set(\"updatedListContent\", updatedContent);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"eval(pm.collectionVariables.get(\"validateClickUpList\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"const responseJson = pm.response.json();\r",
									"validateClickUpList(responseJson);\r",
									"\r",
									"pm.test(\"List ID remains unchanged after update\", function () {\r",
									"    const expectedId = pm.environment.get(\"folderlessListId\");\r",
									"    pm.expect(responseJson.id).to.equal(expectedId);\r",
									"});\r",
									"\r",
									"pm.test(\"List name updated successfully\", function () {\r",
									"    const expectedName = pm.environment.get(\"updatedFolderlessListName\");\r",
									"    const originalName = pm.environment.get(\"folderlessListName\");\r",
									"    \r",
									"    pm.expect(responseJson.name).to.equal(expectedName);\r",
									"    pm.expect(responseJson.name).to.not.equal(originalName);\r",
									"    \r",
									"    console.log(`Name changed from \"${originalName}\" to \"${responseJson.name}\"`);\r",
									"});\r",
									"\r",
									"pm.test(\"Content updated with Unicode characters preserved\", function () {\r",
									"    const expectedContent = pm.environment.get(\"updatedListContent\");\r",
									"    \r",
									"    pm.expect(responseJson.content).to.exist;\r",
									"    pm.expect(responseJson.content).to.include(\"UPDATED CONTENT:\");\r",
									"    pm.expect(responseJson.content).to.include(\"🔄📝✅\");\r",
									"    \r",
									"    if (expectedContent) {\r",
									"        pm.expect(responseJson.content).to.equal(expectedContent);\r",
									"    }\r",
									"    \r",
									"    console.log(`Content updated with ${responseJson.content.length} characters including emojis`);\r",
									"});\r",
									"\r",
									"pm.test(\"Status updated correctly\", function () {\r",
									"    const expectedStatus = pm.environment.get(\"updatedListStatus\");\r",
									"    const expectedColor = pm.environment.get(\"updatedListColor\");\r",
									"    \r",
									"    if (responseJson.status) {\r",
									"        pm.expect(responseJson.status.status).to.equal(expectedStatus);\r",
									"        // Note: API might return different color format than sent\r",
									"        pm.expect(responseJson.status.color).to.exist;\r",
									"        console.log(`Status: ${responseJson.status.status}, Color: ${responseJson.status.color}`);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Due date updated correctly\", function () {\r",
									"    const expectedDueDate = pm.environment.get(\"updatedListDueDate\");\r",
									"    \r",
									"    if (expectedDueDate) {\r",
									"        pm.expect(responseJson.due_date).to.equal(expectedDueDate);\r",
									"    \r",
									"        const dueDate = new Date(parseInt(responseJson.due_date));\r",
									"        const now = new Date();\r",
									"        pm.expect(dueDate.getTime()).to.be.above(now.getTime());\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Immutable fields unchanged\", function () {\r",
									"    const expectedSpaceId = pm.environment.get(\"spaceId\") || pm.collectionVariables.get(\"spaceId\");\r",
									"    \r",
									"    pm.expect(responseJson.deleted).to.be.false;\r",
									"    pm.expect(responseJson.folder.hidden).to.be.true;\r",
									"    pm.expect(responseJson.space.id).to.equal(expectedSpaceId);\r",
									"    pm.expect(responseJson.permission_level).to.equal(\"create\");\r",
									"});\r",
									"\r",
									"pm.test(\"Update appears recent\", function () {\r",
									"    const contentMatch = responseJson.content.match(/timestamp: (\\d+)/);\r",
									"    if (contentMatch) {\r",
									"        const contentTimestamp = parseInt(contentMatch[1]);\r",
									"        const now = Date.now();\r",
									"        const fiveMinutesAgo = now - (5 * 60 * 1000);\r",
									"        \r",
									"        pm.expect(contentTimestamp).to.be.above(fiveMinutesAgo);\r",
									"        pm.expect(contentTimestamp).to.be.below(now + 1000); \r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{updatedFolderlessListName}}\",\r\n  \"description\": \"{{updatedListDescription}}\",\r\n  \"due_date\": {{updatedListDueDate}},\r\n  \"priority\": {{updatedListPriority}},\r\n  \"status\": \"{{updatedListStatus}}\",\r\n  \"color\": \"{{updatedListColor}}\",\r\n  \"content\": \"{{updatedListContent}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{folderlessListId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{folderlessListId}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Folderless List",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"List deleted successfully\", function () {\r",
									"    pm.expect([200, 204]).to.include(pm.response.code);\r",
									"});\r",
									"\r",
									"pm.test(\"Delete operation performance\", function () {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"});\r",
									"\r",
									"pm.test(\"Rate limit check\", function () {\r",
									"    const remaining = pm.response.headers.get(\"x-ratelimit-remaining\");\r",
									"    if (remaining && parseInt(remaining) < 10) {\r",
									"        console.warn(`Rate limit low: ${remaining} requests remaining`);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Environment cleanup\", function () {\r",
									"    if (pm.response.code === 200 || pm.response.code === 204) {\r",
									"        const deletedId = pm.environment.get(\"folderlessListId\");\r",
									"        pm.environment.set(\"deletionCompleted\", \"true\");\r",
									"        console.log(`Successfully deleted list: ${deletedId}`);\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{folderlessListId}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{folderlessListId}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Tasks",
			"item": [
				{
					"name": "Create Task - Basic_Validation",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpTask\"));\r",
									"validateClickUpTask(responseJson);\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateTaskDataMatch\"));\r",
									"validateTaskDataMatch(responseJson);\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateTaskQuality\"));\r",
									"validateTaskQuality(responseJson);\r",
									"\r",
									"pm.test(\"Task ID is saved to environment\", () => {\r",
									"    const taskId = responseJson.id;\r",
									"   pm.expect(taskId).to.exist.and.not.be.empty;\r",
									"    pm.environment.set(\"task_id\", taskId);\r",
									"});\r",
									"\r",
									"eval(pm.collectionVariables.get(\"updateCollectionVariables\"));\r",
									"updateCollectionVariables(responseJson);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let randomNumberName = \"\";\r",
									"for (let i = 0; i < 8; i++) {\r",
									"    randomNumberName += Math.floor(Math.random() * 10); \r",
									"}\r",
									"pm.environment.set(\"task_numeric_name\", randomNumberName);\r",
									"\r",
									"\r",
									"let baseText = \"This is a very long description for testing purposes. Lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \";\r",
									"let longDescription = baseText.repeat(100); \r",
									"pm.environment.set(\"long_description\", longDescription);\r",
									"\r",
									"let randomPriority = Math.floor(Math.random() * 3) + 1;\r",
									"pm.environment.set(\"expected_priority\", randomPriority);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{task_numeric_name}}\",\r\n  \"description\": \"{{long_description}}\",\r\n  \"priority\": {{expected_priority}}\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{template_list_id}}/task",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{template_list_id}}",
								"task"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Task by ID - Consistency Check",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpTask\"));\r",
									"validateClickUpTask(responseJson);\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateTaskConsistency\"));\r",
									"validateTaskConsistency(responseJson);\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpMetadata\"));\r",
									"validateClickUpMetadata(responseJson);\r",
									"\r",
									"eval(pm.collectionVariables.get(\"updateCollectionVariables\"));\r",
									"updateCollectionVariables(responseJson);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Task with Assignment and Unicode",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"chinese_text_field\", \"中文字符测试\")\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpTask\"));\r",
									"validateClickUpTask(responseJson);\r",
									"\r",
									"pm.test(\"Chinese name matches exactly\", () => {\r",
									"    const expectedName = pm.environment.get(\"chinese_text_field\");\r",
									"    const actualName = responseJson.name;\r",
									"    pm.expect(actualName).to.eql(expectedName);\r",
									"});\r",
									"\r",
									"pm.test(\"Chinese name integrity (no broken encoding)\", () => {\r",
									"    const chineseName = responseJson.name;\r",
									"    pm.expect(chineseName).to.not.include(\"?\"); \r",
									"    pm.expect(encodeURIComponent(chineseName)).to.not.include(\"%3F\"); \r",
									"});\r",
									"\r",
									"pm.test(\"Task priority matches sent value\", () => {\r",
									"    const priorityId = responseJson.priority.id;\r",
									"    pm.expect(priorityId).to.eql(\"2\");\r",
									"});\r",
									"\r",
									"pm.test(\"Task is assigned to correct user\", () => {\r",
									"    const expectedUserId = pm.environment.get(\"userId\").toString();\r",
									"    const assignees = responseJson.assignees.map(a => a.id.toString());\r",
									"    pm.expect(assignees).to.include(expectedUserId);\r",
									"});\r",
									"\r",
									"pm.test(\"Task is in template list\", () => {\r",
									"    const expectedListId = pm.environment.get(\"template_list_id\");\r",
									"    pm.expect(responseJson.list.id).to.eql(expectedListId);\r",
									"});\r",
									"\r",
									"pm.test(\"Task 2 ID is saved to environment\", () => {\r",
									"    const taskId = responseJson.id;\r",
									"    pm.expect(taskId, \"Task 2 ID should exist\").to.be.not.empty;\r",
									"    pm.environment.set(\"task_id_2\", taskId);\r",
									"});\r",
									"\r",
									"eval(pm.collectionVariables.get(\"updateCollectionVariables\"));\r",
									"updateCollectionVariables(responseJson);\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{chinese_text_field}}\",\r\n  \"description\": \"Task 2 assigned to template list and user\",\r\n  \"assignees\": [\"{{userId}}\"],\r\n  \"priority\": 2\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{template_list_id}}/task",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{template_list_id}}",
								"task"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Task - Boundary Conditions Test",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let longNumericName = \"\";\r",
									"for (let i = 0; i < 50; i++) {\r",
									"    longNumericName += Math.floor(Math.random() * 10); \r",
									"}\r",
									"let farFutureStart = new Date();\r",
									"farFutureStart.setFullYear(farFutureStart.getFullYear() + 2);\r",
									"let farFutureDue = new Date(farFutureStart);\r",
									"farFutureDue.setMonth(farFutureDue.getMonth() + 6);\r",
									"const allTags = [\"urgent\", \"testing\", \"api\", \"automation\", \"development\", \"review\", \"critical\", \"production\"];\r",
									"const maxTimeEstimate = 24 * 60 * 60 * 1000;\r",
									"const specialDescription = \"Task 3: Testing boundary conditions with special chars: @#$%^&*()_+-=[]{}|;':\\\",./<>? and unicode: 测试 ñáéíóú\";\r",
									"\r",
									"pm.environment.set(\"task3_long_numeric_name\", longNumericName);\r",
									"pm.environment.set(\"task3_special_description\", JSON.stringify(specialDescription).slice(1, -1)); \r",
									"pm.environment.set(\"task3_tags\", JSON.stringify(allTags));\r",
									"pm.environment.set(\"farFutureStartTimestamp\", farFutureStart.getTime());\r",
									"pm.environment.set(\"farFutureDueTimestamp\", farFutureDue.getTime());\r",
									"pm.environment.set(\"maxTimeEstimate\", maxTimeEstimate);\r",
									"\r",
									"const startTimestamp = farFutureStart.getTime();\r",
									"const dueTimestamp = farFutureDue.getTime(); \r",
									"\r",
									"pm.environment.set(\"task3_far_future_start\", startTimestamp);\r",
									"pm.environment.set(\"task3_far_future_due\", dueTimestamp); \r",
									"pm.environment.set(\"farFutureStartTimestamp\", startTimestamp);\r",
									"pm.environment.set(\"task3_min_priority\", \"1\");\r",
									"pm.environment.set(\"task3_max_tags\", JSON.stringify(allTags));\r",
									"pm.environment.set(\"task3_max_time_estimate\", maxTimeEstimate);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const TEST_CONFIG = {\r",
									"    MAX_NAME_LENGTH: 50,\r",
									"    MAX_TAGS_COUNT: 8,\r",
									"    MIN_PRIORITY: \"1\", \r",
									"    MILLISECONDS_IN_DAY: 24 * 60 * 60 * 1000,\r",
									"    TIME_TOLERANCE_MS: 60 * 1000,\r",
									"    REQUIRED_SPECIAL_CHARS: [\"@#$%^&*()\", \"测试\", \"ñáéíóú\", '\"'] // Characters that commonly cause encoding issues in APIs\r",
									"};\r",
									"\r",
									"let responseJson = {};\r",
									"try {\r",
									"    responseJson = pm.response.json();\r",
									"} catch (e) {\r",
									"    pm.test(\"Response is valid JSON\", () => {\r",
									"        pm.expect.fail(`Failed to parse JSON: ${e.message}`);\r",
									"    });\r",
									"}\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpTask\"));\r",
									"validateClickUpTask(responseJson);\r",
									"\r",
									"pm.test(\"Task 3 ID is saved to environment\", () => {\r",
									"    if (responseJson.id) {\r",
									"        pm.expect(responseJson.id, \"Task 3 ID should exist\").to.be.a(\"string\").and.not.empty;\r",
									"        pm.environment.set(\"task_id_3\", responseJson.id);\r",
									"    } else {\r",
									"        pm.expect.fail(\"Task 3 ID does not exist in response\");\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Long numeric name is handled correctly\", () => {\r",
									"    const expectedName = pm.environment.get(\"task3_long_numeric_name\");\r",
									"    const actualName = responseJson.name;\r",
									"    \r",
									"    pm.expect(actualName).to.equal(expectedName);\r",
									"    pm.expect(actualName.length).to.equal(TEST_CONFIG.MAX_NAME_LENGTH);\r",
									"    pm.expect(actualName).to.match(/^\\d+$/);\r",
									"});\r",
									"\r",
									"pm.test(\"Minimum priority (Urgent) is set correctly\", () => {\r",
									"    pm.expect(responseJson.priority.id).to.equal(TEST_CONFIG.MIN_PRIORITY);\r",
									"});\r",
									"\r",
									"pm.test(\"Far future dates are handled correctly\", () => {\r",
									"    const startDate = responseJson.start_date;\r",
									"    const dueDate = responseJson.due_date;\r",
									"    \r",
									"    pm.expect(startDate, \"Start date should exist\").to.exist;\r",
									"    pm.expect(dueDate, \"Due date should exist\").to.exist;\r",
									"    \r",
									"    const startMs = parseInt(startDate);\r",
									"    const dueMs = parseInt(dueDate);\r",
									"    \r",
									"    const expectedStartMs = parseInt(pm.environment.get(\"task3_far_future_start\"));\r",
									"    const expectedDueMs = parseInt(pm.environment.get(\"task3_far_future_due\"));\r",
									"    // 24h tolerance for server processing and timezone differences \r",
									"    const LARGE_TIME_TOLERANCE = 24 * 60 * 60 * 1000; \r",
									"    \r",
									"    const startDiff = Math.abs(startMs - expectedStartMs);\r",
									"    const dueDiff = Math.abs(dueMs - expectedDueMs);\r",
									"    \r",
									"    pm.expect(startDiff).to.be.below(LARGE_TIME_TOLERANCE, \r",
									"        `Start date difference: ${startDiff}ms (${startDiff/1000/60/60}h)`);\r",
									"    pm.expect(dueDiff).to.be.below(LARGE_TIME_TOLERANCE, \r",
									"        `Due date difference: ${dueDiff}ms (${dueDiff/1000/60/60}h)`);\r",
									"    pm.expect(startMs).to.be.above(Date.now(), \"Start date should be in future\");\r",
									"    pm.expect(dueMs).to.be.above(startMs, \"Due date should be after start date\");\r",
									"});\r",
									"\r",
									"pm.test(\"Maximum tags are handled correctly\", () => {\r",
									"    const expectedTags = JSON.parse(pm.environment.get(\"task3_max_tags\"));\r",
									"    \r",
									"    pm.expect(responseJson).to.have.property('tags');\r",
									"    pm.expect(responseJson.tags).to.be.an('array');\r",
									"    pm.expect(responseJson.tags.length).to.equal(TEST_CONFIG.MAX_TAGS_COUNT);\r",
									"    \r",
									"    const actualTagNames = responseJson.tags.map(function(tag) {\r",
									"        return tag.name;\r",
									"    });\r",
									"    \r",
									"    expectedTags.forEach(function(expectedTagName) {\r",
									"        pm.expect(actualTagNames).to.include(expectedTagName, `Missing tag: ${expectedTagName}`);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Maximum time estimate is handled correctly\", () => {\r",
									"    const expectedTimeEstimate = parseInt(pm.environment.get(\"task3_max_time_estimate\"));\r",
									"    const actualTimeEstimate = parseInt(responseJson.time_estimate);\r",
									"    \r",
									"    pm.expect(actualTimeEstimate).to.equal(expectedTimeEstimate);\r",
									"    pm.expect(actualTimeEstimate).to.equal(TEST_CONFIG.MILLISECONDS_IN_DAY);\r",
									"});\r",
									"\r",
									"pm.test(\"Special characters in description are preserved\", () => {\r",
									"    const actualDescription = responseJson.description;\r",
									"    \r",
									"    pm.expect(actualDescription).to.include(\"Testing boundary conditions\");\r",
									"    \r",
									"    TEST_CONFIG.REQUIRED_SPECIAL_CHARS.forEach(function(chars) {\r",
									"        pm.expect(actualDescription).to.include(chars, `Missing special characters: ${chars}`);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Task handles boundary conditions without errors\", () => {\r",
									"    const conditions = [\r",
									"        { name: 'name length', actual: responseJson.name.length, expected: TEST_CONFIG.MAX_NAME_LENGTH },\r",
									"        { name: 'priority', actual: responseJson.priority.id, expected: TEST_CONFIG.MIN_PRIORITY },\r",
									"        { name: 'tags count', actual: responseJson.tags.length, expected: TEST_CONFIG.MAX_TAGS_COUNT },\r",
									"        { name: 'time estimate', actual: parseInt(responseJson.time_estimate), expected: TEST_CONFIG.MILLISECONDS_IN_DAY }\r",
									"    ];\r",
									"    \r",
									"    conditions.forEach(function(condition) {\r",
									"        pm.expect(condition.actual).to.equal(condition.expected, \r",
									"            `${condition.name} should be ${condition.expected}, got ${condition.actual}`);\r",
									"    });\r",
									"});\r",
									"\r",
									"eval(pm.collectionVariables.get(\"updateCollectionVariables\"));\r",
									"updateCollectionVariables(responseJson);\r",
									"\r",
									"pm.test(\"Far future dates are handled correctly\", () => {\r",
									"    const startDate = responseJson.start_date;\r",
									"    const dueDate = responseJson.due_date;    \r",
									"    pm.expect(startDate, \"Start date should exist\").to.exist;\r",
									"    pm.expect(dueDate, \"Due date should exist\").to.exist;\r",
									"    \r",
									"    const startMs = parseInt(startDate);\r",
									"    const dueMs = parseInt(dueDate);\r",
									"    const expectedStartMs = parseInt(pm.environment.get(\"task3_far_future_start\"));\r",
									"    const expectedDueMs = parseInt(pm.environment.get(\"task3_far_future_due\"));\r",
									"});\r",
									"    \r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"name\": \"{{task3_long_numeric_name}}\",\r\n    \"description\": \"{{task3_special_description}}\",\r\n    \"priority\": 1,\r\n    \"start_date\": {{farFutureStartTimestamp}},\r\n    \"due_date\": {{farFutureDueTimestamp}},\r\n    \"tags\": {{task3_tags}},\r\n    \"time_estimate\": {{maxTimeEstimate}}\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{additional_list_id}}/task",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{additional_list_id}}",
								"task"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Task - Invalid Data (Missing Name)",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 400 Bad Request\", () => {\r",
									"    pm.response.to.have.status(400);\r",
									"});\r",
									"\r",
									"pm.test(\"Response indicates name field issue\", () => {\r",
									"    const responseJson = pm.response.json();\r",
									"    const responseText = JSON.stringify(responseJson).toLowerCase();\r",
									"    \r",
									"    pm.expect(responseText).to.satisfy((text) => {\r",
									"        return text.includes(\"name\") && (\r",
									"            text.includes(\"required\") || \r",
									"            text.includes(\"missing\") || \r",
									"            text.includes(\"invalid\") ||\r",
									"            text.includes(\"empty\")\r",
									"        );\r",
									"    }, \"Response should indicate name field issue\");\r",
									"});\r",
									"\r",
									"pm.test(\"Response time is reasonable for error\", () => {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(2000);\r",
									"});\r",
									"\r",
									"pm.test(\"Error response has proper structure\", () => {\r",
									"    const responseJson = pm.response.json();\r",
									"    const errorFields = [\"error\", \"err\", \"message\", \"errors\"];\r",
									"    const hasErrorField = errorFields.some(field => responseJson.hasOwnProperty(field));\r",
									"    \r",
									"    pm.expect(hasErrorField).to.be.true;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"description\": \"Task without name - should fail\",\r\n  \"priority\": 2\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{template_list_id}}/task",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{template_list_id}}",
								"task"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Task - Invalid Date Format",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code indicates validation error\", () => {\r",
									"    pm.expect([400, 422]).to.include(pm.response.code);\r",
									"});\r",
									"\r",
									"pm.test(\"Error message mentions date issue\", () => {\r",
									"    const responseJson = pm.response.json();\r",
									"    const errorMessage = (responseJson.error || responseJson.err || responseJson.message || \"\").toLowerCase();\r",
									"    \r",
									"    pm.expect(errorMessage).to.satisfy(msg => \r",
									"        msg.includes(\"date\") || msg.includes(\"time\") || msg.includes(\"invalid\")\r",
									"    , \"Error should mention date/time validation issue\");\r",
									"});\r",
									"\r",
									"pm.test(\"Error response has proper structure\", () => {\r",
									"    const responseJson = pm.response.json();\r",
									"    \r",
									"    const hasErrorField = responseJson.error || responseJson.err || responseJson.message || responseJson.errors;\r",
									"    pm.expect(hasErrorField).to.exist;\r",
									"    \r",
									"    if (typeof hasErrorField === 'string') {\r",
									"        pm.expect(hasErrorField.trim().length).to.be.above(0);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Response time acceptable for validation error\", () => {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(1000);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"Task with invalid date\",\r\n  \"description\": \"Testing date validation\",\r\n  \"due_date\": \"invalid-date-format\",\r\n  \"start_date\": \"2024-13-45\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{template_list_id}}/task",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{template_list_id}}",
								"task"
							]
						}
					},
					"response": []
				},
				{
					"name": "Add Task to Multiple Lists",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseCode = pm.response.code;\r",
									"const responseTime = pm.response.responseTime;\r",
									"const responseText = pm.response.text();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"pm.test(\"Task add to list operation completed successfully\", () => {\r",
									"    pm.expect(responseCode).to.be.oneOf([200, 204]);\r",
									"});\r",
									"\r",
									"pm.test(\"Response body is empty as expected\", () => {\r",
									"    pm.expect(responseText).to.equal(\"{}\");\r",
									"    \r",
									"    try {\r",
									"        const parsed = JSON.parse(responseText);\r",
									"        pm.expect(Object.keys(parsed)).to.have.length(0);\r",
									"    } catch (e) {\r",
									"        pm.expect.fail(\"Response should be valid empty JSON object\");\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Request URL contains correct list and task IDs\", () => {\r",
									"    const requestUrl = pm.request.url.toString();\r",
									"    const additionalListId = pm.environment.get(\"additional_list_id\");\r",
									"    const taskId = pm.environment.get(\"task_id_2\");\r",
									"    \r",
									"    pm.expect(requestUrl).to.include(`/list/${additionalListId}/task/${taskId}`);\r",
									"});\r",
									"\r",
									"pm.test(\"Request payload is correct for add operation\", () => {\r",
									"    const requestBody = pm.request.body;\r",
									"    \r",
									"    if (requestBody && requestBody.raw) {\r",
									"        const bodyJson = JSON.parse(requestBody.raw);\r",
									"        pm.expect(bodyJson).to.have.property('add');\r",
									"        pm.expect(bodyJson.add).to.be.true;\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Rate limits are monitored\", () => {\r",
									"    if (pm.response.headers.has(\"x-ratelimit-remaining\")) {\r",
									"        const remaining = parseInt(pm.response.headers.get(\"x-ratelimit-remaining\"));\r",
									"        const limit = parseInt(pm.response.headers.get(\"x-ratelimit-limit\"));\r",
									"        \r",
									"        pm.expect(remaining).to.be.within(0, limit);\r",
									"        \r",
									"        if (remaining < 10) {\r",
									"            console.warn(`Rate limit low: ${remaining}/${limit} remaining`);\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Operation represents valid task-to-list relationship\", () => {\r",
									"    const listId = pm.environment.get(\"additional_list_id\");\r",
									"    const taskId = pm.environment.get(\"task_id_2\");\r",
									"    const templateListId = pm.environment.get(\"template_list_id\");\r",
									"\r",
									"    pm.expect(listId).to.not.equal(templateListId);\r",
									"    pm.expect(listId).to.not.be.undefined;\r",
									"    pm.expect(taskId).to.not.be.undefined;\r",
									"});\r",
									"\r",
									"pm.test(\"Environment variables updated for chain testing\", () => {\r",
									"    const listId = pm.environment.get(\"additional_list_id\");\r",
									"    const taskId = pm.environment.get(\"task_id_2\");\r",
									"    \r",
									"    pm.expect(listId).to.be.a('string').and.not.empty;\r",
									"    pm.expect(taskId).to.be.a('string').and.not.empty;\r",
									"\r",
									"    pm.environment.set(\"task_added_to_additional_list\", \"true\");\r",
									"    pm.environment.set(\"add_operation_timestamp\", Date.now().toString());\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"add\": true\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{additional_list_id}}/task/{{task_id_2}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{additional_list_id}}",
								"task",
								"{{task_id_2}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Upload Task Attachment",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"upload_start_time\", Date.now().toString());\r",
									"pm.environment.set(\"attachment_filename\", \"test.txt\");"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"responseJson = pm.response.json();\r",
									"const responseCode = pm.response.code;\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"pm.test(\"Attachment is successfully created\", () => {\r",
									"    pm.expect(responseJson).to.have.property('id');\r",
									"    pm.expect(responseJson).to.have.property('url');\r",
									"    pm.expect(responseJson).to.have.property('name');\r",
									"    pm.expect(responseJson).to.have.property('extension');\r",
									"    pm.expect(responseJson).to.have.property('title');\r",
									"    pm.expect(responseJson).to.have.property('date');\r",
									"    pm.expect(responseJson).to.have.property('version');\r",
									"    pm.expect(responseJson).to.have.property('source');\r",
									"    pm.expect(responseJson).to.have.property('url_w_query');\r",
									"    pm.expect(responseJson).to.have.property('url_w_host');\r",
									"});\r",
									"\r",
									"pm.test(\"Attachment has correct filename and title\", () => {\r",
									"    const responseFilename = responseJson.name;\r",
									"    const responseTitle = responseJson.title;\r",
									"    pm.expect(responseFilename).to.equal(\"test.txt\");\r",
									"});\r",
									"\r",
									"pm.test(\"Attachment extension is correct\", () => {\r",
									"    pm.expect(responseJson.extension).to.equal(\"txt\");\r",
									"  \r",
									"    pm.expect(responseJson.name).to.match(new RegExp(`\\\\.${responseJson.extension}$`));\r",
									"});\r",
									"\r",
									"pm.test(\"Attachment ID has correct format\", () => {\r",
									"    pm.expect(responseJson.id).to.match(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\.txt$/);\r",
									"});\r",
									"\r",
									"pm.test(\"Attachment URLs are valid\", () => {\r",
									"    pm.expect(responseJson.url).to.match(/^https:\\/\\/t\\d+\\.p\\.clickup-attachments\\.com\\/.+/);\r",
									"    pm.expect(responseJson.url_w_query).to.include(responseJson.url);\r",
									"    pm.expect(responseJson.url_w_query).to.include(\"?view=open\");\r",
									"    \r",
									"    pm.expect(responseJson.url_w_host).to.equal(responseJson.url);\r",
									"});\r",
									"\r",
									"pm.test(\"Attachment date is valid\", () => {\r",
									"    const uploadStartTime = parseInt(pm.environment.get(\"upload_start_time\")) || Date.now() - 60000;\r",
									"    const currentTime = Date.now();\r",
									"    \r",
									"    console.log(\"Upload start time:\", uploadStartTime);\r",
									"    console.log(\"Response date:\", responseJson.date);\r",
									"    console.log(\"Current time:\", currentTime);\r",
									"    \r",
									"    pm.expect(responseJson.date).to.be.a('number');\r",
									"    pm.expect(responseJson.date).to.be.greaterThan(0);\r",
									"    pm.expect(responseJson.date).to.be.at.least(uploadStartTime);\r",
									"    pm.expect(responseJson.date).to.be.below(currentTime + 10000);\r",
									"    \r",
									"    const oneMinuteAgo = currentTime - (60 * 1000);\r",
									"    pm.expect(responseJson.date).to.be.at.least(oneMinuteAgo);\r",
									"});\r",
									"\r",
									"pm.test(\"Attachment version and source are correct\", () => {\r",
									"    pm.expect(responseJson.version).to.equal(\"0\");\r",
									"    \r",
									"    pm.expect(responseJson.source).to.equal(1);\r",
									"});\r",
									"\r",
									"pm.test(\"Attachment thumbnails are null for txt files\", () => {\r",
									"    pm.expect(responseJson.thumbnail_small).to.be.null;\r",
									"    pm.expect(responseJson.thumbnail_medium).to.be.null;\r",
									"    pm.expect(responseJson.thumbnail_large).to.be.null;\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "formdata",
							"formdata": [
								{
									"key": "attachment",
									"type": "file",
									"src": "test.txt"
								},
								{
									"key": "filename",
									"value": "{{attachment_filename}}",
									"type": "text"
								}
							]
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id}}/attachment",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id}}",
								"attachment"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Task - Complete Fields Modification",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"let shortName = \"Updated-\" + pm.variables.replaceIn(\"{{$randomWord}}\");\r",
									"let simpleDescription = \"Updated description with normal text and émojis 🚀\";\r",
									"let currentDate = new Date();\r",
									"let nearFutureStart = new Date(currentDate.getTime() + 7 * 24 * 60 * 60 * 1000); \r",
									"let nearFutureDue = new Date(nearFutureStart.getTime() + 3 * 24 * 60 * 60 * 1000); \r",
									"\r",
									"pm.environment.set(\"updated_task3_name\", shortName);\r",
									"pm.environment.set(\"updated_task3_description\", simpleDescription);\r",
									"pm.environment.set(\"updated_task3_start_date\", nearFutureStart.getTime());\r",
									"pm.environment.set(\"updated_task3_due_date\", nearFutureDue.getTime());\r",
									"pm.environment.set(\"update_timestamp\", currentDate.getTime());\r",
									"\r",
									"pm.environment.set(\"original_task3_name\", pm.environment.get(\"task3_long_numeric_name\"));\r",
									"pm.environment.set(\"original_task3_priority\", \"1\");\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"const updateTimestamp = pm.environment.get(\"update_timestamp\");\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpTask\"));\r",
									"validateClickUpTask(responseJson);\r",
									"\r",
									"pm.test(\"Task name updated from numeric to alpha\", () => {\r",
									"    const expectedName = pm.environment.get(\"updated_task3_name\");\r",
									"    const originalName = pm.environment.get(\"original_task3_name\");\r",
									"    \r",
									"    pm.expect(responseJson.name).to.eql(expectedName);\r",
									"    pm.expect(responseJson.name).to.not.eql(originalName);\r",
									"    pm.expect(responseJson.name.length).to.be.below(30); \r",
									"    pm.expect(responseJson.name).to.match(/^Updated-/); \r",
									"});\r",
									"\r",
									"pm.test(\"Priority successfully changed from Urgent(1) to Low(3)\", () => {\r",
									"    pm.expect(responseJson.priority.id).to.eql(\"3\");\r",
									"    pm.expect(responseJson.priority.id).to.not.eql(pm.environment.get(\"original_task3_priority\"));\r",
									"});\r",
									"\r",
									"pm.test(\"Description updated with emoji support\", () => {\r",
									"    const expectedDescription = pm.environment.get(\"updated_task3_description\");\r",
									"    pm.expect(responseJson.description).to.eql(expectedDescription);\r",
									"    pm.expect(responseJson.description).to.include(\"🚀\"); \r",
									"    pm.expect(responseJson.description).to.include(\"émojis\");\r",
									"});\r",
									"\r",
									"pm.test(\"Time estimate reduced from 24h to 1h\", () => {\r",
									"    const actualEstimate = parseInt(responseJson.time_estimate);\r",
									"    pm.expect(actualEstimate).to.eql(3600000); \r",
									"    pm.expect(actualEstimate).to.be.below(24 * 60 * 60 * 1000);\r",
									"});\r",
									"\r",
									"pm.test(\"Dates updated to near future (within next month)\", () => {\r",
									"    const startDate = parseInt(responseJson.start_date);\r",
									"    const dueDate = parseInt(responseJson.due_date);\r",
									"    const now = Date.now();\r",
									"    const oneMonthFromNow = now + (30 * 24 * 60 * 60 * 1000);\r",
									"    \r",
									"    pm.expect(startDate).to.be.above(now);\r",
									"    pm.expect(startDate).to.be.below(oneMonthFromNow);\r",
									"    pm.expect(dueDate).to.be.above(startDate);\r",
									"    pm.expect(dueDate).to.be.below(oneMonthFromNow);\r",
									"});\r",
									"\r",
									"\r",
									"pm.test(\"Task update timestamp is recent\", () => {\r",
									"    const updatedDate = parseInt(responseJson.date_updated || responseJson.date_done);\r",
									"    if (updatedDate) {\r",
									"        pm.expect(updatedDate).to.be.above(updateTimestamp - 5000); \r",
									"        pm.expect(updatedDate).to.be.below(Date.now() + 5000);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Task still belongs to correct list\", () => {\r",
									"    const expectedListId = pm.environment.get(\"additional_list_id\");\r",
									"    pm.expect(responseJson.list.id).to.eql(expectedListId);\r",
									"});\r",
									"\r",
									"\r",
									"pm.test(\"Update handles character encoding correctly\", () => {\r",
									"    const description = responseJson.description;\r",
									"    pm.expect(description).to.not.include(\"?\"); \r",
									"    pm.expect(description).to.not.include(\"�\"); \r",
									"});\r",
									"\r",
									"pm.test(\"All required fields maintained after update\", () => {\r",
									"    ['id', 'name', 'description', 'priority', 'list', 'creator'].forEach(field => {\r",
									"        pm.expect(responseJson).to.have.property(field);\r",
									"    });\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"name\": \"{{updated_task3_name}}\",\r\n  \"description\": \"{{updated_task3_description}}\",\r\n  \"priority\": 3,\r\n  \"time_estimate\": 3600000,\r\n  \"start_date\": {{updated_task3_start_date}},\r\n  \"due_date\": {{updated_task3_due_date}}\r\n\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id_3}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id_3}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Task - Permanent Removal",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseCode = pm.response.code;\r",
									"const responseTime = pm.response.responseTime;\r",
									"const deletionTimestamp = pm.environment.get(\"deletion_timestamp\");\r",
									"const responseText = pm.response.text();\r",
									"\r",
									"pm.test(\"Task deletion returns appropriate success status\", () => {\r",
									"    pm.expect(responseCode).to.be.oneOf([200, 204]);\r",
									"});\r",
									"\r",
									"pm.test(\"Deletion response time is efficient\", () => {\r",
									"    pm.expect(responseTime).to.be.below(3000);\r",
									"});\r",
									"\r",
									"pm.test(\"Deletion request processed within reasonable timeframe\", () => {\r",
									"    const processingTime = Date.now() - deletionTimestamp;\r",
									"    pm.expect(processingTime).to.be.below(5000);\r",
									"});\r",
									"\r",
									"pm.test(\"Response body is appropriate for deletion\", () => {\r",
									"    if (responseCode === 200) {\r",
									"        if (responseText === \"{}\") {\r",
									"            pm.expect(responseText).to.equal(\"{}\");\r",
									"        } else if (responseText.trim().length > 0) {\r",
									"            try {\r",
									"                const responseJson = pm.response.json();\r",
									"                pm.expect(responseJson).to.satisfy(obj => \r",
									"                    obj.deleted === true || \r",
									"                    obj.status === 'deleted' || \r",
									"                    obj.message || \r",
									"                    Object.keys(obj).length === 0\r",
									"                );\r",
									"            } catch (e) {\r",
									"                pm.expect(responseText).to.be.a('string').and.not.empty;\r",
									"            }\r",
									"        }\r",
									"    } else if (responseCode === 204) {\r",
									"        pm.expect(responseText).to.satisfy(text => \r",
									"            text === \"\" || text === \"{}\" || !text\r",
									"        );\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Response headers are appropriate\", () => {\r",
									"    const contentType = pm.response.headers.get(\"Content-Type\");\r",
									"    if (contentType) {\r",
									"        pm.expect(contentType).to.satisfy(ct => \r",
									"            ct.includes(\"application/json\") || ct.includes(\"text/plain\")\r",
									"        );\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"deletion_timestamp\", Date.now());\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id_3}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id_3}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify Task Deletion - 404 Response",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"verification_start_time\", Date.now());"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseCode = pm.response.code;\r",
									"const verificationTime = Date.now() - pm.environment.get(\"verification_start_time\");\r",
									"\r",
									"pm.test(\"Task deletion properly verified\", () => {\r",
									"    if (responseCode === 404) {\r",
									"        console.log(\"Task completely removed (404 Not Found)\");\r",
									"        pm.expect(responseCode).to.eql(404);\r",
									"    } else if (responseCode === 410) {\r",
									"        console.log(\"Task marked as Gone (410)\");\r",
									"        pm.expect(responseCode).to.eql(410);\r",
									"    } else if (responseCode === 200) {\r",
									"        console.log(\"Task still exists - deletion failed\");\r",
									"        pm.expect.fail(\"Task deletion failed: received 200 OK, expected 404/410 for deleted resource\");\r",
									"    } else {\r",
									"        pm.expect.fail(`Unexpected response code: ${responseCode}. Expected 404 or 410 for deleted resource`);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Deletion verification response time acceptable\", () => {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(2000);\r",
									"    pm.expect(verificationTime).to.be.below(3000);\r",
									"});\r",
									"\r",
									"if (responseCode >= 400) {\r",
									"    pm.test(\"Error response structure is proper\", () => {\r",
									"        const responseText = pm.response.text();\r",
									"        pm.expect(responseText).to.be.a('string');\r",
									"        \r",
									"        if (responseText.trim().length > 0) {\r",
									"            try {\r",
									"                const errorJson = pm.response.json();\r",
									"                pm.expect(errorJson).to.satisfy((obj) => {\r",
									"                    return obj.err || obj.error || obj.message || obj.ECODE;\r",
									"                });\r",
									"            } catch (e) {\r",
									"                console.log(\"Non-JSON error response received\");\r",
									"            }\r",
									"        }\r",
									"    });\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id_3}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id_3}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "List Tasks - Post Operations Verification",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"final_verification_timestamp\", Date.now());"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"const task1Id = pm.environment.get(\"task_id\");\r",
									"const task2Id = pm.environment.get(\"task_id_2\");\r",
									"const deletedTask3Id = pm.environment.get(\"deleted_task3_id\");\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"pm.test(\"Response contains tasks array\", () => {\r",
									"    pm.expect(responseJson).to.have.property('tasks');\r",
									"    pm.expect(responseJson.tasks).to.be.an('array');\r",
									"});\r",
									"\r",
									"pm.test(\"Task 3 is completely absent from list (DELETED)\", () => {\r",
									"    const taskIds = responseJson.tasks.map(function(task) { \r",
									"        return task.id; \r",
									"    });\r",
									"    pm.expect(taskIds).to.not.include(deletedTask3Id);\r",
									"    \r",
									"    const taskNames = responseJson.tasks.map(function(task) { \r",
									"        return task.name; \r",
									"    });\r",
									"    const deletedTaskName = pm.environment.get(\"deleted_task3_name\");\r",
									"    if (deletedTaskName) {\r",
									"        pm.expect(taskNames).to.not.include(deletedTaskName);\r",
									"    }\r",
									"    \r",
									"    console.log(\"Task 3 successfully purged from list\");\r",
									"});\r",
									"\r",
									"pm.test(\"Task 2 multi-list status verification\", () => {\r",
									"    const taskIds = responseJson.tasks.map(function(task) { \r",
									"        return task.id; \r",
									"    });\r",
									"    const timlLimitReached = pm.environment.get(\"timl_limit_reached\") === \"true\";\r",
									"    \r",
									"    if (timlLimitReached) {\r",
									"        console.log(\"Plan limit prevented multi-list - Task 2 should NOT be in Additional List\");\r",
									"        pm.expect(taskIds).to.not.include(task2Id);\r",
									"    } else {\r",
									"        console.log(\"Checking if Task 2 was successfully added to Additional List\");\r",
									"        if (taskIds.includes(task2Id)) {\r",
									"            console.log(\" Task 2 successfully exists in both lists\");\r",
									"        } else {\r",
									"            console.log(\"ℹ Task 2 not found in Additional List (may be plan limitation)\");\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Task 1 correctly absent from Additional List\", () => {\r",
									"    const taskIds = responseJson.tasks.map(function(task) { \r",
									"        return task.id; \r",
									"    });\r",
									"    pm.expect(taskIds).to.not.include(task1Id);\r",
									"});\r",
									"\r",
									"pm.test(\"List maintains integrity after task operations\", () => {\r",
									"    const taskCount = responseJson.tasks.length;\r",
									"    pm.expect(taskCount).to.be.at.least(0);\r",
									"    pm.expect(taskCount).to.be.below(100); \r",
									"    \r",
									"    const taskIds = responseJson.tasks.map(function(task) { \r",
									"        return task.id; \r",
									"    });\r",
									"    \r",
									"    const uniqueIds = taskIds.filter(function(id, index, arr) {\r",
									"        return arr.indexOf(id) === index;\r",
									"    });\r",
									"    \r",
									"    pm.expect(taskIds.length).to.eql(uniqueIds.length, \"No duplicate task IDs\");\r",
									"});\r",
									"\r",
									"pm.test(\"List retrieval performance acceptable\", () => {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(3000);\r",
									"});\r",
									"\r",
									"pm.test(\"No tasks contain suspicious or corrupted data\", () => {\r",
									"    for (let i = 0; i < responseJson.tasks.length; i++) {\r",
									"        const task = responseJson.tasks[i];\r",
									"        pm.expect(task.name).to.be.a('string').and.not.empty;\r",
									"        pm.expect(task.id).to.match(/^[a-zA-Z0-9]+$/, `Task ${i} has invalid ID format`);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"All tasks belong to correct list\", () => {\r",
									"    const expectedListId = pm.environment.get(\"additional_list_id\");\r",
									"    \r",
									"    for (let i = 0; i < responseJson.tasks.length; i++) {\r",
									"        const task = responseJson.tasks[i];\r",
									"        pm.expect(task.list.id).to.equal(expectedListId, `Task ${i} belongs to wrong list`);\r",
									"    }\r",
									"    \r",
									"    console.log(\"All tasks verified to belong to Additional List\");\r",
									"});\r",
									"\r",
									"console.log(\"=== LIST VERIFICATION SUMMARY ===\");\r",
									"console.log(\"Total tasks in Additional List:\", responseJson.tasks.length);\r",
									"console.log(\"Task 1 present:\", responseJson.tasks.map(function(t) { return t.id; }).includes(task1Id) ? \"YES\" : \"NO\");\r",
									"console.log(\"Task 2 present:\", responseJson.tasks.map(function(t) { return t.id; }).includes(task2Id) ? \"YES\" : \"NO\");\r",
									"console.log(\"Task 3 present:\", responseJson.tasks.map(function(t) { return t.id; }).includes(deletedTask3Id) ? \"YES (ERROR!)\" : \"NO (CORRECT)\");\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{additional_list_id}}/task",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{additional_list_id}}",
								"task"
							]
						}
					},
					"response": []
				},
				{
					"name": "List Tasks - Template Integrity Check",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"const task1Id = pm.environment.get(\"task_id\");\r",
									"const task2Id = pm.environment.get(\"task_id_2\");\r",
									"const deletedTask3Id = pm.environment.get(\"deleted_task3_id\");\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"pm.test(\"Template List contains Task 1 (primary location)\", () => {\r",
									"    const taskIds = responseJson.tasks.map(function(task) {\r",
									"        return task.id;\r",
									"    });\r",
									"    pm.expect(taskIds).to.include(task1Id);\r",
									"});\r",
									"\r",
									"pm.test(\"Template List contains Task 2 (original creation location)\", () => {\r",
									"    const taskIds = responseJson.tasks.map(function(task) {\r",
									"        return task.id;\r",
									"    });\r",
									"    pm.expect(taskIds).to.include(task2Id);\r",
									"});\r",
									"\r",
									"pm.test(\"Task 3 completely purged from Template List (DELETED)\", () => {\r",
									"    const taskIds = responseJson.tasks.map(function(task) {\r",
									"        return task.id;\r",
									"    });\r",
									"    pm.expect(taskIds).to.not.include(deletedTask3Id);\r",
									"});\r",
									"\r",
									"pm.test(\"Template List has expected task count\", () => {\r",
									"    const expectedMinTasks = 2; \r",
									"    pm.expect(responseJson.tasks.length).to.be.at.least(expectedMinTasks);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/list/{{template_list_id}}/task",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"list",
								"{{template_list_id}}",
								"task"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Comments",
			"item": [
				{
					"name": "Create Parent Comment",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const timestamp = Date.now();\r",
									"const commentText = `🚀 Parent comment created at ${timestamp} - test comment with special chars: ąęść żółć 中文 💯`;\r",
									"\r",
									"pm.environment.set(\"parent_comment_text\", commentText);\r",
									"pm.environment.set(\"parent_comment_timestamp\", timestamp.toString());\r",
									"\r",
									"const userId = pm.environment.get(\"userId\");\r",
									"pm.environment.set(\"comment_assignee_id\", userId);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"  // NOTE: ClickUp's create comment endpoint does NOT return the comment text in the response\r",
									"\r",
									"const responseJson = pm.response.json();\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpComment\"));\r",
									"validateClickUpComment(responseJson);\r",
									"\r",
									"pm.test(\"ClickUp comment creation - CORE validation\", () => {\r",
									"    pm.expect(responseJson.id, \"Comment ID is REQUIRED\").to.exist;\r",
									"    pm.expect(responseJson.hist_id, \"History ID is REQUIRED\").to.exist;\r",
									"    pm.expect(responseJson.version, \"Version info is REQUIRED\").to.exist;\r",
									"    \r",
									"    pm.expect(responseJson.version.operation, \"Operation MUST be 'c' for creation\").to.equal('c');\r",
									"    pm.expect(responseJson.version.object_type, \"Object type MUST be 'comment'\").to.equal('comment');\r",
									"    pm.expect(responseJson.deleted, \"Newly created comment MUST NOT be deleted\").to.not.equal(true);\r",
									"    \r",
									"    const versionObjectId = responseJson.version?.object_id;\r",
									"    pm.expect(versionObjectId, \"Version object_id MUST match comment ID\").to.equal(responseJson.id.toString());\r",
									"    pm.expect(responseJson.id, \"Comment ID must be in reasonable range\").to.be.above(1000000);\r",
									"    \r",
									"    pm.environment.set(\"parent_comment_id\", responseJson.id.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"ClickUp relationships and workspace validation\", () => {\r",
									"    const expectedTaskId = pm.environment.get(\"task_id\");\r",
									"    const expectedUserId = pm.environment.get(\"comment_assignee_id\");\r",
									"    const workspaceId = responseJson.version?.workspace_id;\r",
									"    const relationships = responseJson.version?.data?.relationships || [];\r",
									"    \r",
									"    pm.expect(workspaceId, \"Workspace ID is MANDATORY\").to.exist.and.be.above(0);\r",
									"    pm.expect(relationships, \"Relationships array MUST exist\").to.be.an('array').and.have.length.above(0);\r",
									"    \r",
									"    const taskRelationship = relationships.find(rel => rel.type === \"comment-parent\" && rel.object_type === \"task\");\r",
									"    const authorRelationship = relationships.find(rel => rel.type === \"comment-author\" && rel.object_type === \"user\");\r",
									"    \r",
									"    pm.expect(taskRelationship, \"Comment MUST have task parent relationship\").to.exist;\r",
									"    pm.expect(taskRelationship.object_id, \"Task ID must match expected\").to.equal(expectedTaskId);\r",
									"    \r",
									"    pm.expect(authorRelationship, \"Comment MUST have author relationship\").to.exist;\r",
									"    pm.expect(authorRelationship.object_id.toString(), \"Author ID must match expected\").to.equal(expectedUserId.toString());\r",
									"    \r",
									"    const workspaceInconsistencies = relationships.filter(rel => \r",
									"        rel.workspace_id !== workspaceId.toString()\r",
									"    ).map(rel => `${rel.type}: expected ${workspaceId}, got ${rel.workspace_id}`);\r",
									"    \r",
									"    pm.expect(workspaceInconsistencies, `Workspace inconsistencies: ${workspaceInconsistencies.join(', ')}`).to.have.length(0);\r",
									"\r",
									"});\r",
									"\r",
									"pm.test(\"Timestamp and version data validation\", () => {\r",
									"    const responseTimestamp = responseJson.date;\r",
									"    const requestTimestamp = parseInt(pm.environment.get(\"parent_comment_timestamp\"));\r",
									"    const version = responseJson.version;\r",
									"    \r",
									"    pm.expect(responseTimestamp, \"Creation timestamp is MANDATORY\").to.exist.and.be.above(0);\r",
									"    \r",
									"    const timeDiff = Math.abs(responseTimestamp - requestTimestamp);\r",
									"    pm.expect(timeDiff, \"Creation time drift too large\").to.be.below(3000);\r",
									"    \r",
									"    const requiredVersionFields = ['object_type', 'object_id', 'workspace_id', 'operation', 'data'];\r",
									"    const missingFields = requiredVersionFields.filter(field => \r",
									"        !version.hasOwnProperty(field) || version[field] === null || version[field] === undefined\r",
									"    );\r",
									"    \r",
									"    pm.expect(missingFields, `Version missing fields: ${missingFields.join(', ')}`).to.have.length(0);\r",
									"    pm.expect(version.data.relationships, \"Relationships array required\").to.be.an('array').and.have.length.above(0);\r",
									"    pm.expect(version.data.context, \"Context required for audit trail\").to.exist;\r",
									"\r",
									"    const versionChanges = version.data?.changes || [];\r",
									"    const dateCreatedChange = versionChanges.find(change => change.field === \"date_created\");\r",
									"    \r",
									"    pm.expect(dateCreatedChange, \"date_created change MUST exist\").to.exist;\r",
									"    pm.expect(dateCreatedChange.after, \"Version timestamp must match response\").to.equal(responseTimestamp);\r",
									"    \r",
									"});\r",
									"\r",
									"pm.test(\"Error detection and business logic validation\", () => {\r",
									"    const taskId = pm.environment.get(\"task_id\");\r",
									"    const userId = pm.environment.get(\"comment_assignee_id\");\r",
									"    const relationships = responseJson.version?.data?.relationships || [];\r",
									"    \r",
									"    pm.expect(taskId, \"Task ID required for validation\").to.exist;\r",
									"    pm.expect(userId, \"User ID required for validation\").to.exist;\r",
									"    \r",
									"    const errorFields = ['error', 'errors', 'error_message', 'message', 'err'];\r",
									"    const foundErrors = errorFields.filter(field => \r",
									"        responseJson.hasOwnProperty(field) && responseJson[field]\r",
									"    );\r",
									"    pm.expect(foundErrors, \"No error fields should be present\").to.have.length(0);\r",
									"    \r",
									"    const hasTaskRelation = relationships.some(rel => \r",
									"        rel.type === \"comment-parent\" && rel.object_id === taskId\r",
									"    );\r",
									"    const hasAuthorRelation = relationships.some(rel => \r",
									"        rel.type === \"comment-author\" && rel.object_id.toString() === userId.toString()\r",
									"    );\r",
									"    \r",
									"    pm.expect(hasTaskRelation, \"Comment must be linked to correct task\").to.be.true;\r",
									"    pm.expect(hasAuthorRelation, \"Comment must be attributed to correct user\").to.be.true;\r",
									"    \r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"comment_text\": \"{{parent_comment_text}}\",\r\n  \"assignee\": \"{{comment_assignee_id}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id}}/comment",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id}}",
								"comment"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Threaded Comment - Length Limits Test",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"const testIteration = parseInt(pm.environment.get(\"length_test_iteration\") || \"1\");\r",
									"const maxIterations = 3; \r",
									"\r",
									"const lengthTestCases = {\r",
									"  1: {\r",
									"    name: \"Minimal Length\",\r",
									"    length: 1,\r",
									"    shouldPass: true,\r",
									"    customText: \".\"  \r",
									"  },\r",
									"  2: {\r",
									"    name: \"Normal Length\",\r",
									"    length: 2000,\r",
									"    shouldPass: true\r",
									"  },\r",
									"  3: {\r",
									"    name: \"Very Long Length\",\r",
									"    length: 30000,\r",
									"    shouldPass: true\r",
									"  }\r",
									"};\r",
									"\r",
									"const currentTest = lengthTestCases[testIteration];\r",
									"const timestamp = Date.now();\r",
									"let commentText;\r",
									"\r",
									"if (currentTest.customText) {\r",
									"  commentText = currentTest.customText;\r",
									"} else {\r",
									"  const unicodeText = `ąęść żółć 日本語 中文 🧵🎭`;\r",
									"  const baseText = `Threaded reply ${currentTest.name} test created at ${timestamp} - Unicode: `;\r",
									"  const padding = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore. \";\r",
									"  \r",
									"  const reservedSpace = baseText.length + unicodeText.length;\r",
									"  const paddingNeeded = currentTest.length - reservedSpace;\r",
									"  \r",
									"  if (paddingNeeded > 0) {\r",
									"\r",
									"    let paddingText = \"\";\r",
									"    while (paddingText.length < paddingNeeded) {\r",
									"      paddingText += padding;\r",
									"    }\r",
									"    paddingText = paddingText.substring(0, paddingNeeded);\r",
									"\r",
									"    commentText = baseText + paddingText + unicodeText;\r",
									"  } else {\r",
									"    commentText = (baseText + unicodeText).substring(0, currentTest.length);\r",
									"  }\r",
									"}\r",
									"pm.environment.set(\"threaded_comment_text\", commentText);\r",
									"pm.environment.set(\"test_case_name\", currentTest.name);\r",
									"pm.environment.set(\"expected_length\", currentTest.length.toString());\r",
									"const nextIteration = testIteration < maxIterations ? testIteration + 1 : 1;\r",
									"pm.environment.set(\"length_test_iteration\", nextIteration.toString());\r",
									"\r",
									"console.log(`Testing: ${currentTest.name} (${commentText.length} characters)`);\r",
									"console.log(`First 100 chars: ${commentText.substring(0, 100)}`);\r",
									"console.log(`Last 100 chars: ${commentText.substring(Math.max(0, commentText.length - 100))}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"const responseCode = pm.response.code;\r",
									"const testCaseName = pm.environment.get(\"test_case_name\");\r",
									"const expectedLength = parseInt(pm.environment.get(\"expected_length\"));\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpComment\"));\r",
									"validateClickUpComment(responseJson);\r",
									"\r",
									"pm.test(`${testCaseName} - Length boundary validation`, () => {\r",
									"  const sentText = pm.environment.get(\"threaded_comment_text\");\r",
									"  const sentLength = sentText.length;\r",
									"  \r",
									"  pm.expect(sentLength, \"Sent comment should have expected length\").to.equal(expectedLength);\r",
									"  pm.expect(responseJson.id, \"Comment should have valid ID\").to.exist.and.be.above(0);\r",
									"  \r",
									"  pm.environment.set(\"threaded_comment_id\", responseJson.id.toString());\r",
									"  \r",
									"  if (expectedLength === 1) {\r",
									"    pm.expect(sentText, \"Single character comment should be a dot\").to.equal(\".\");\r",
									"  }\r",
									"});\r",
									"\r",
									"pm.test(`${testCaseName} - Threaded comment creation core validation`, () => {\r",
									"  pm.expect(responseJson.id, \"Threaded comment ID is required\").to.exist.and.be.above(0);\r",
									"  pm.expect(responseJson.date, \"Threaded comment should have creation date\").to.exist;\r",
									"  pm.expect(responseJson.version?.operation, \"Should be creation operation\").to.equal(\"c\");\r",
									"  \r",
									"  console.log(\"User field not found in comment response - this is expected for ClickUp threaded comments\");\r",
									"});\r",
									"\r",
									"pm.test(`${testCaseName} - Threaded comment parent relationship`, () => {\r",
									"  const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"  const threadedCommentId = responseJson.id.toString();\r",
									"  \r",
									"  pm.expect(parentCommentId, \"Parent comment ID should exist\").to.exist;\r",
									"  pm.expect(threadedCommentId, \"Threaded comment should have different ID than parent\")\r",
									"    .to.not.equal(parentCommentId);\r",
									" \r",
									"  pm.environment.set(\"threaded_comment_parent_id\", parentCommentId);\r",
									"});\r",
									"\r",
									"pm.test(`${testCaseName} - Content and Unicode preservation`, () => {\r",
									"  const originalText = pm.environment.get(\"threaded_comment_text\");\r",
									"  \r",
									"  if (expectedLength === 1) {\r",
									"    pm.expect(originalText, \"Minimal comment should be preserved exactly\").to.have.lengthOf(1);\r",
									"    pm.expect(originalText, \"Minimal comment should be a dot\").to.equal(\".\");\r",
									"  } else {\r",
									"    \r",
									"    pm.expect(originalText, \"Should contain Polish characters\").to.include(\"ąęść żółć\");\r",
									"    pm.expect(originalText, \"Should contain Japanese characters\").to.include(\"日本語\");\r",
									"    pm.expect(originalText, \"Should contain Chinese characters\").to.include(\"中文\");\r",
									"    pm.expect(originalText, \"Should contain thread emojis\").to.match(/[🧵🎭]/);\r",
									"    \r",
									"    const last50chars = originalText.substring(originalText.length - 50);\r",
									"    pm.expect(last50chars, \"Unicode should be preserved at the end\").to.include(\"中文\");\r",
									"  }\r",
									"});\r",
									"\r",
									"pm.test(`${testCaseName} - Response time performance`, () => {\r",
									"  const responseTime = pm.response.responseTime;\r",
									"  let maxTime;\r",
									"  \r",
									"  if (expectedLength === 1) {\r",
									"    maxTime = 1500; \r",
									"  } else if (expectedLength <= 2000) {\r",
									"    maxTime = 3000; \r",
									"  } else {\r",
									"    maxTime = 8000; \r",
									"  }\r",
									"  \r",
									"  pm.expect(responseTime, `Response time should be reasonable for ${testCaseName}`)\r",
									"    .to.be.below(maxTime);\r",
									"    \r",
									"  console.log(`Response time: ${responseTime}ms (limit: ${maxTime}ms)`);\r",
									"});\r",
									"\r",
									"pm.test(`${testCaseName} - API stability and error handling`, () => {\r",
									"  const errorFields = ['error', 'errors', 'error_message', 'message', 'err'];\r",
									"  const foundErrors = errorFields.filter(field => \r",
									"    responseJson.hasOwnProperty(field) && responseJson[field]\r",
									"  );\r",
									"  \r",
									"  pm.expect(foundErrors, \"Response should not contain error indicators\").to.have.length(0);\r",
									"  \r",
									"  pm.expect(responseJson.version, \"Version info should be present\").to.exist;\r",
									"  pm.expect(responseJson.hist_id, \"History ID should be present\").to.exist;\r",
									"});\r",
									"\r",
									"pm.test(`${testCaseName} - Rate limiting awareness`, () => {\r",
									"  if (pm.response.headers.has(\"x-ratelimit-remaining\")) {\r",
									"    const remaining = parseInt(pm.response.headers.get(\"x-ratelimit-remaining\"));\r",
									"    console.log(`Rate limit remaining: ${remaining}`);\r",
									"    \r",
									"    if (remaining < 10) {\r",
									"      console.warn(\"Rate limit approaching - consider adding delays between tests\");\r",
									"    }\r",
									"\r",
									"    if (expectedLength >= 30000 && remaining < 50) {\r",
									"      console.log(\"Large comment may have impacted rate limiting\");\r",
									"    }\r",
									"  }\r",
									"});\r",
									"\r",
									"pm.test(`${testCaseName} - Content integrity verification`, () => {\r",
									"  const originalText = pm.environment.get(\"threaded_comment_text\");\r",
									"  \r",
									"  pm.expect(originalText.length, \"Text length must match exactly\").to.equal(expectedLength);\r",
									"  \r",
									"  if (expectedLength > 1) {\r",
									"    pm.expect(originalText, \"Should not contain control characters\").to.not.match(/[\\x00-\\x1F\\x7F]/);\r",
									"    pm.expect(originalText, \"Should contain timestamp\").to.include(pm.environment.get(\"threaded_comment_text\").match(/\\d{13}/)?.[0] || \"timestamp\");\r",
									"  }\r",
									"  \r",
									"  console.log(`Content integrity verified for ${expectedLength} characters`);\r",
									"});\r",
									"\r",
									"const maxIterations = 3; \r",
									"const currentIteration = parseInt(pm.environment.get(\"length_test_iteration\"));\r",
									"const justCompletedIteration = currentIteration === 1 ? 3 : currentIteration - 1;\r",
									"\r",
									"if (justCompletedIteration < maxIterations) {\r",
									"    console.log(`Starting iteration ${currentIteration}`);\r",
									"    postman.setNextRequest(pm.info.requestName);\r",
									"} else {\r",
									"    console.log(\" All 3 length test iterations completed\");\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"comment_text\": \"{{threaded_comment_text}}\",\r\n  \"assignee\": \"{{userId}}\",\r\n  \"notify_all\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/comment/{{parent_comment_id}}/reply",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"comment",
								"{{parent_comment_id}}",
								"reply"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Additional Parent Comment",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const timestamp = Date.now();\r",
									"const commentText = `🔗 Second parent comment created at ${timestamp} - additional test comment with Polish chars: ąęść żółć and emojis 🎯`;\r",
									"\r",
									"pm.environment.set(\"second_comment_text\", commentText);\r",
									"pm.environment.set(\"second_comment_timestamp\", timestamp.toString());\r",
									"\r",
									"const userId = pm.environment.get(\"userId\");\r",
									"pm.environment.set(\"second_comment_assignee_id\", userId);\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateClickUpComment\"));\r",
									"validateClickUpComment(responseJson);\r",
									"\r",
									"pm.test(\"Second comment creation - basic validation\", () => {\r",
									"    pm.expect(responseJson.id, \"Second comment ID required\").to.exist.and.be.above(0);\r",
									"    pm.expect(responseJson.version?.operation, \"Should be creation operation\").to.equal('c');\r",
									"\r",
									"    pm.environment.set(\"second_comment_id\", responseJson.id.toString());\r",
									"    pm.environment.set(\"second_comment_timestamp\", responseJson.date.toString());\r",
									"  \r",
									"});\r",
									"\r",
									"pm.test(\"Comments comparison - Different IDs and timestamps\", () => {\r",
									"    const firstCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const secondCommentId = responseJson.id.toString();\r",
									"    const firstTimestamp = parseInt(pm.environment.get(\"parent_comment_timestamp\"));\r",
									"    const secondTimestamp = responseJson.date;\r",
									" \r",
									"    pm.expect(secondCommentId, \"Second comment must have different ID than first\")\r",
									"        .to.not.equal(firstCommentId);\r",
									"\r",
									"    pm.expect(secondTimestamp, \"Second comment should be created after first\")\r",
									"        .to.be.above(firstTimestamp);\r",
									"});\r",
									"\r",
									"pm.test(\"Comments comparison - Same task context\", () => {\r",
									"    const relationships = responseJson.version?.data?.relationships || [];\r",
									"    const taskRelationship = relationships.find(rel => rel.type === \"comment-parent\");\r",
									"    \r",
									"    const expectedTaskId = pm.environment.get(\"task_id\");\r",
									"    \r",
									"    pm.expect(taskRelationship?.object_id, \"Second comment should belong to same task\").to.equal(expectedTaskId);\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"comment_text\": \"{{second_comment_text}}\",\r\n  \"assignee\": {{second_comment_assignee_id}},\r\n  \"notify_all\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id}}/comment",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id}}",
								"comment"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Comment  - Empty Text",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code indicates validation error\", () => {\r",
									"    pm.expect([400, 422]).to.include(pm.response.code);\r",
									"});\r",
									"\r",
									"pm.test(\"No comment created with empty text\", () => {\r",
									"    const responseJson = pm.response.json();\r",
									"    pm.expect(responseJson.id).to.be.oneOf([undefined, null]);\r",
									"    \r",
									"    const hasError = responseJson.error || responseJson.message || responseJson.err;\r",
									"    pm.expect(hasError, \"Should contain error information\").to.exist;\r",
									"});\r",
									"\r",
									"pm.test(\"Validation error is descriptive\", () => {\r",
									"    const responseJson = pm.response.json();\r",
									"    \r",
									"    const errorFields = ['error', 'message', 'err', 'errors'];\r",
									"    const hasErrorField = errorFields.some(field => responseJson[field]);\r",
									"    \r",
									"    pm.expect(hasErrorField, \"Response should contain error description\").to.be.true;\r",
									"    \r",
									"    const errorMessage = responseJson.error || responseJson.message || responseJson.err || '';\r",
									"    pm.expect(errorMessage.toString().toLowerCase(), \"Error should mention empty/missing content\")\r",
									"        .to.satisfy(msg => msg.includes('empty') || msg.includes('required') || msg.includes('missing'));\r",
									"});\r",
									"\r",
									"pm.test(\"Response structure is valid error format\", () => {\r",
									"    const responseJson = pm.response.json();\r",
									"    pm.expect(responseJson).to.be.an('object');\r",
									"    pm.expect(responseJson.success).to.not.equal(true);\r",
									"    pm.expect(responseJson.created).to.not.equal(true);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"comment_text\": \"\",\r\n  \"assignee\": \"{{userId}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id}}/comment",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id}}",
								"comment"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get All Task Comments",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"const commentsArray = responseJson.comments || [];\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateCommentArray\"));\r",
									"validateCommentArray(commentsArray, 2);\r",
									"\r",
									"pm.test(\"Current test session comments validation\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const secondCommentId = pm.environment.get(\"second_comment_id\");\r",
									"    const threadedCommentId = pm.environment.get(\"threaded_comment_id\");\r",
									"    \r",
									"    console.log(\"Looking for comments:\");\r",
									"    console.log(\"- Parent:\", parentCommentId);\r",
									"    console.log(\"- Second:\", secondCommentId);\r",
									"    console.log(\"- Threaded:\", threadedCommentId);\r",
									"    \r",
									"    const commentIds = commentsArray.map(c => c.id.toString());\r",
									"    \r",
									"    if (parentCommentId) {\r",
									"        pm.expect(commentIds, `Parent comment ${parentCommentId} should be present`)\r",
									"            .to.include(parentCommentId);\r",
									"    }\r",
									"    \r",
									"    if (secondCommentId) {\r",
									"        pm.expect(commentIds, `Second comment ${secondCommentId} should be present`)\r",
									"            .to.include(secondCommentId);\r",
									"    }\r",
									"    if (threadedCommentId) {\r",
									"        const threadedFound = commentIds.includes(threadedCommentId);\r",
									"        if (threadedFound) {\r",
									"            console.log(\"Threaded comment found in main comments list\");\r",
									"        } else {\r",
									"            console.log(\"Threaded comment not found in main list - may need separate endpoint\");\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Comment content verification\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const parentComment = commentsArray.find(c => c.id.toString() === parentCommentId);\r",
									"    \r",
									"    if (parentComment) {\r",
									"        const actualText = parentComment.comment_text || parentComment.comment[0]?.text;\r",
									"        const expectedText = pm.environment.get(\"parent_comment_text\");\r",
									"        \r",
									"        console.log(\"Parent comment text verification:\");\r",
									"        console.log(\"Expected:\", expectedText?.substring(0, 100) + \"...\");\r",
									"        console.log(\"Actual:\", actualText?.substring(0, 100) + \"...\");\r",
									"        \r",
									"        if (expectedText) {\r",
									"            pm.expect(actualText, \"Parent comment text should match\").to.equal(expectedText);\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Length Limits Test Investigation\", () => {\r",
									"    const possibleThreadedComments = commentsArray.filter(c => {\r",
									"        const text = c.comment_text || c.comment[0]?.text || \"\";\r",
									"        return text.includes(\"Threaded\") || text.includes(\"Length\") || text === \".\";\r",
									"    });\r",
									"    \r",
									"    console.log(`Found ${possibleThreadedComments.length} potential threaded comments`);\r",
									"    \r",
									"    possibleThreadedComments.forEach((comment, index) => {\r",
									"        const text = comment.comment_text || comment.comment[0]?.text;\r",
									"        console.log(`Threaded ${index + 1}: ID=${comment.id}, text=\"${text}\"`);\r",
									"    });\r",
									"    \r",
									"\r",
									"    const commentsWithReplies = commentsArray.filter(c => c.reply_count > 0);\r",
									"    console.log(`Comments with replies: ${commentsWithReplies.length}`);\r",
									"    \r",
									"    commentsWithReplies.forEach(comment => {\r",
									"        console.log(`Comment ${comment.id} has ${comment.reply_count} replies`);\r",
									"    });\r",
									"});\r",
									"\r",
									"pm.test(\"Unicode preservation check\", () => {\r",
									"    const allTexts = commentsArray.map(c => \r",
									"        c.comment_text || c.comment[0]?.text || \"\"\r",
									"    ).join(\" \");\r",
									"    const hasUnicode = /[ąęść żółć]/.test(allTexts) || allTexts.includes(\"中文\");\r",
									"    \r",
									"    if (commentsArray.length > 0) {\r",
									"        pm.expect(hasUnicode, \"Should find Unicode in comments from this session\").to.be.true;\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Session comments completeness\", () => {\r",
									"    const expectedIds = [\r",
									"        pm.environment.get(\"parent_comment_id\"),\r",
									"        pm.environment.get(\"second_comment_id\")\r",
									"    ].filter(id => id);\r",
									"    \r",
									"    const foundIds = commentsArray.map(c => c.id.toString());\r",
									"    \r",
									"    expectedIds.forEach(expectedId => {\r",
									"        pm.expect(foundIds, `Comment ${expectedId} should be present`)\r",
									"            .to.include(expectedId);\r",
									"    });\r",
									"    \r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id}}/comment",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id}}",
								"comment"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Comment Text",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"\r",
									"const timestamp = Date.now();\r",
									"const updatedText = `✏️ UPDATED parent comment at ${timestamp} - modified with special chars: ąęść żółć 中文 💯 EDITED`;\r",
									"\r",
									"pm.environment.set(\"updated_comment_text\", updatedText);\r",
									"pm.environment.set(\"update_timestamp\", timestamp.toString());\r",
									"\r",
									"console.log(\"Updated text:\", updatedText);\r",
									"console.log(\"Original text:\", pm.environment.get(\"parent_comment_text\"));"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"// PUT specific validation - ClickUp PUT returns empty object {} for successful updates\r",
									"\r",
									"pm.test(\"Update request data validation\", () => {\r",
									"    const updatedText = pm.environment.get(\"updated_comment_text\");\r",
									"    const updateTimestamp = pm.environment.get(\"update_timestamp\");\r",
									"    const originalText = pm.environment.get(\"parent_comment_text\");\r",
									"    \r",
									"\r",
									"    pm.expect(updatedText, \"Updated text should be set\").to.exist.and.not.be.empty;\r",
									"    pm.expect(updateTimestamp, \"Update timestamp should be recorded\").to.exist;\r",
									"    pm.expect(originalText, \"Original text should be available for comparison\").to.exist;\r",
									"    \r",
									"    pm.expect(updatedText, \"Updated text should contain 'UPDATED' marker\").to.include(\"UPDATED\");\r",
									"    pm.expect(updatedText, \"Updated text should contain 'EDITED' marker\").to.include(\"EDITED\");\r",
									"    pm.expect(updatedText, \"Updated text should be different from original\").to.not.equal(originalText);\r",
									"\r",
									"});\r",
									"\r",
									"pm.test(\"PUT operation error detection\", () => {\r",
									"    const errorFields = ['error', 'errors', 'error_message', 'message', 'err'];\r",
									"    const foundErrors = errorFields.filter(field => \r",
									"        responseJson.hasOwnProperty(field) && responseJson[field]\r",
									"    );\r",
									"    \r",
									"    pm.expect(foundErrors, \"PUT response should not contain error indicators\").to.have.length(0);\r",
									"});\r",
									"\r",
									"pm.test(\"Update business logic validation\", () => {\r",
									"    const commentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const updatedText = pm.environment.get(\"updated_comment_text\");\r",
									"    const updateTimestamp = parseInt(pm.environment.get(\"update_timestamp\"));\r",
									"    \r",
									"    pm.expect(commentId, \"Comment ID should be available for update\").to.exist;\r",
									"    pm.expect(updatedText, \"Updated text should be defined\").to.exist;\r",
									"    pm.expect(updateTimestamp, \"Update timestamp should be reasonable\").to.be.above(0);\r",
									"    \r",
									"    const originalTimestamp = parseInt(pm.environment.get(\"parent_comment_timestamp\"));\r",
									"    if (originalTimestamp) {\r",
									"        pm.expect(updateTimestamp, \"Update should happen after original creation\")\r",
									"            .to.be.above(originalTimestamp);\r",
									"    }\r",
									"    \r",
									"    pm.environment.set(\"comment_update_confirmed\", \"true\");\r",
									"    pm.environment.set(\"last_update_timestamp\", updateTimestamp.toString());\r",
									"\r",
									"});\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"comment_text\": \"{{updated_comment_text}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/comment/{{parent_comment_id}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"comment",
								"{{parent_comment_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Resolve Comment",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"pm.environment.set(\"resolve_timestamp\", Date.now().toString());"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"console.log(\"ClickUp returned empty response for resolve - this is expected\");\r",
									"\r",
									"pm.test(\"Rate limiting functionality\", () => {\r",
									"    pm.expect(pm.response.headers.has(\"x-ratelimit-limit\")).to.be.true;\r",
									"    pm.expect(pm.response.headers.has(\"x-ratelimit-remaining\")).to.be.true;\r",
									"    pm.expect(pm.response.headers.has(\"x-ratelimit-reset\")).to.be.true;\r",
									"    \r",
									"    const limit = parseInt(pm.response.headers.get(\"x-ratelimit-limit\"));\r",
									"    const remaining = parseInt(pm.response.headers.get(\"x-ratelimit-remaining\"));\r",
									"    const reset = parseInt(pm.response.headers.get(\"x-ratelimit-reset\"));\r",
									"    \r",
									"    pm.expect(limit).to.be.a('number').and.to.be.above(0);\r",
									"    pm.expect(remaining).to.be.a('number').and.to.be.within(0, limit);\r",
									"    pm.expect(reset).to.be.a('number').and.to.be.above(Date.now() / 1000);\r",
									"    \r",
									"    console.log(`Rate limit: ${remaining}/${limit}, resets at: ${new Date(reset * 1000)}`);\r",
									"});\r",
									"\r",
									"\r",
									"pm.test(\"Business logic validation\", () => {\r",
									"    const commentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const resolveTimestamp = Date.now();\r",
									"    \r",
									"    pm.expect(commentId, \"Comment ID should be available for resolve operation\").to.exist;\r",
									"    \r",
									"    pm.environment.set(\"resolve_timestamp\", resolveTimestamp.toString());\r",
									"    pm.environment.set(\"resolve_operation\", \"completed\");\r",
									"    \r",
									"    const possibleIdHeaders = [\"x-request-id\", \"x-trace-id\", \"x-correlation-id\", \"request-id\"];\r",
									"    const foundIdHeader = possibleIdHeaders.find(header => pm.response.headers.has(header));\r",
									"    \r",
									"    if (foundIdHeader) {\r",
									"        pm.environment.set(\"last_request_id\", pm.response.headers.get(foundIdHeader));\r",
									"        console.log(`Stored request ID from ${foundIdHeader} header`);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"No sensitive data exposure\", () => {\r",
									"    const responseText = pm.response.text().toLowerCase();\r",
									"    const headers = pm.response.headers.toJSON();\r",
									"    const sensitivePatterns = [\r",
									"        'password', 'api_key', 'secret', 'token', 'private_key',\r",
									"        'database', 'connection_string', 'internal_error', 'stack trace'\r",
									"    ];\r",
									"    \r",
									"    sensitivePatterns.forEach(pattern => {\r",
									"        pm.expect(responseText, `Response should not contain: ${pattern}`).to.not.include(pattern);\r",
									"    });\r",
									"\r",
									"    const serverHeader = pm.response.headers.get(\"server\");\r",
									"    if (serverHeader) {\r",
									"        pm.expect(serverHeader).to.not.match(/\\d+\\.\\d+\\.\\d+/); \r",
									"        console.log(`Server header: ${serverHeader}`);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Response structure integrity\", () => {\r",
									"    const responseBody = pm.response.json();\r",
									"\r",
									"    pm.expect(responseBody).to.not.have.property('error');\r",
									"    pm.expect(responseBody).to.not.have.property('errors');\r",
									"    pm.expect(responseBody).to.not.have.property('error_message');\r",
									"    pm.expect(responseBody).to.not.have.property('exception');\r",
									"    \r",
									"    pm.expect(Object.keys(responseBody)).to.have.length(0);\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n  \"resolved\": true\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{clickupBaseUrl}}/comment/{{parent_comment_id}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"comment",
								"{{parent_comment_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify Comment Update Results",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseJson = pm.response.json();\r",
									"const commentsData = responseJson.comments || [];\r",
									"\r",
									"eval(pm.collectionVariables.get(\"validateBasicResponse\"));\r",
									"validateBasicResponse();\r",
									"\r",
									"pm.test(\"Updated comment is present in response\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    \r",
									"    pm.expect(parentCommentId, \"Parent comment ID should be available\").to.exist;\r",
									"    pm.expect(commentsData, \"Comments array should exist\").to.be.an('array');\r",
									"    \r",
									"    const updatedComment = commentsData.find(c => c.id.toString() === parentCommentId);\r",
									"    pm.expect(updatedComment, \"Updated comment should be found in response\").to.exist;\r",
									"});\r",
									"\r",
									"pm.test(\"Comment text was successfully updated\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const expectedUpdatedText = pm.environment.get(\"updated_comment_text\");\r",
									"    const originalText = pm.environment.get(\"parent_comment_text\");\r",
									"    \r",
									"    const updatedComment = commentsData.find(c => c.id.toString() === parentCommentId);\r",
									"    \r",
									"    pm.expect(expectedUpdatedText, \"Expected updated text should be available\").to.exist;\r",
									"    pm.expect(originalText, \"Original text should be available for comparison\").to.exist;\r",
									"    \r",
									"    if (updatedComment) {\r",
									"        const actualText = updatedComment.comment_text || updatedComment.comment[0]?.text;\r",
									"        \r",
									"        pm.expect(actualText, \"Comment should have text content\").to.exist;\r",
									"        pm.expect(actualText, \"Updated text should match exactly what was sent\")\r",
									"            .to.equal(expectedUpdatedText);\r",
									"        pm.expect(actualText, \"Updated text should be different from original\")\r",
									"            .to.not.equal(originalText);\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Comment update markers are preserved\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const updatedComment = commentsData.find(c => c.id.toString() === parentCommentId);\r",
									"    \r",
									"    if (updatedComment) {\r",
									"        const actualText = updatedComment.comment_text || updatedComment.comment[0]?.text || \"\";\r",
									"        \r",
									"        pm.expect(actualText, \"Updated text should contain 'UPDATED' marker\").to.include(\"UPDATED\");\r",
									"        pm.expect(actualText, \"Updated text should contain 'EDITED' marker\").to.include(\"EDITED\");\r",
									"        pm.expect(actualText, \"Updated text should contain edit emoji\").to.include(\"✏️\");\r",
									"        \r",
									"        // Verify Unicode characters are preserved after update\r",
									"        pm.expect(actualText, \"Polish diacritics should be preserved\").to.match(/[ąęść żółć]/);\r",
									"        pm.expect(actualText, \"Chinese characters should be preserved\").to.include(\"中文\");\r",
									"        pm.expect(actualText, \"Emoji should be preserved\").to.include(\"💯\");\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Comment resolved status is correctly applied\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const resolveOperation = pm.environment.get(\"resolve_operation\");\r",
									"    const updatedComment = commentsData.find(c => c.id.toString() === parentCommentId);\r",
									"    \r",
									"    if (updatedComment && resolveOperation === \"completed\") {\r",
									"        pm.expect(updatedComment.resolved, \"Comment should be marked as resolved\").to.be.true;\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Comment metadata consistency after updates\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const expectedUserId = pm.environment.get(\"userId\");\r",
									"    const updatedComment = commentsData.find(c => c.id.toString() === parentCommentId);\r",
									"    \r",
									"    if (updatedComment) {\r",
									"        pm.expect(updatedComment.user, \"Comment should have user information\").to.exist;\r",
									"        pm.expect(updatedComment.user.id.toString(), \"User ID should remain unchanged\")\r",
									"            .to.equal(expectedUserId.toString());\r",
									"        \r",
									"        pm.expect(updatedComment.assignee, \"Comment should have assignee\").to.exist;\r",
									"        pm.expect(updatedComment.assignee.id.toString(), \"Assignee ID should remain unchanged\")\r",
									"            .to.equal(expectedUserId.toString());\r",
									"        \r",
									"        pm.expect(updatedComment.reply_count, \"Reply count should be number\").to.be.a('number');\r",
									"        pm.expect(updatedComment.reactions, \"Reactions should be array\").to.be.an('array');\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"Basic response integrity\", () => {\r",
									"    const secondCommentId = pm.environment.get(\"second_comment_id\");\r",
									"    \r",
									"    pm.expect(commentsData, \"Should have comments array\").to.be.an('array');\r",
									"    pm.expect(commentsData.length, \"Should have at least one comment\").to.be.above(0);\r",
									"    \r",
									"    if (secondCommentId && secondCommentId !== \"undefined\") {\r",
									"        const secondComment = commentsData.find(c => c.id.toString() === secondCommentId);\r",
									"        if (secondComment) {\r",
									"            const expectedSecondText = pm.environment.get(\"second_comment_text\");\r",
									"            const actualSecondText = secondComment.comment_text || secondComment.comment[0]?.text;\r",
									"            \r",
									"            pm.expect(actualSecondText, \"Second comment should not be affected by first comment update\")\r",
									"                .to.equal(expectedSecondText);\r",
									"        }\r",
									"    }\r",
									"});\r",
									"\r",
									"pm.test(\"End-to-end update verification summary\", () => {\r",
									"    const parentCommentId = pm.environment.get(\"parent_comment_id\");\r",
									"    const updateConfirmed = pm.environment.get(\"comment_update_confirmed\");\r",
									"    \r",
									"    pm.expect(parentCommentId, \"Parent comment ID should be tracked\").to.exist;\r",
									"    pm.expect(updateConfirmed, \"Update confirmation should be recorded\").to.equal(\"true\");\r",
									"    \r",
									"    pm.environment.set(\"update_verification_passed\", \"true\");\r",
									"    pm.environment.set(\"verification_timestamp\", Date.now().toString());\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/task/{{task_id}}/comment",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"task",
								"{{task_id}}",
								"comment"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete Second Comment",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseCode = pm.response.code;\r",
									"const responseTime = pm.response.responseTime;\r",
									"\r",
									"pm.test(\"Comment deletion returns appropriate success status\", () => {\r",
									"    pm.expect(responseCode).to.be.oneOf([200, 204]);\r",
									"    console.log(\"Deletion status:\", responseCode);\r",
									"});\r",
									"\r",
									"pm.test(\"Deletion response time is efficient\", () => {\r",
									"    pm.expect(responseTime).to.be.below(3000);\r",
									"    console.log(\"Deletion completed in:\", responseTime + \"ms\");\r",
									"});\r",
									"\r",
									"if (responseCode === 200 && pm.response.text()) {\r",
									"    try {\r",
									"        const responseJson = pm.response.json();\r",
									"        pm.test(\"Deletion response contains confirmation\", () => {\r",
									"            pm.expect(responseJson).to.satisfy((obj) => {\r",
									"                return obj.deleted === true || \r",
									"                       obj.status === 'deleted' || \r",
									"                       obj.message || \r",
									"                       Object.keys(obj).length === 0;\r",
									"            });\r",
									"        });\r",
									"    } catch (e) {\r",
									"        console.log(\"No JSON response body (expected for deletion)\");\r",
									"    }\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/comment/{{second_comment_id}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"comment",
								"{{second_comment_id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Verify  Deletion",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const responseCode = pm.response.code;\r",
									"const responseBody = pm.response.text();\r",
									"\r",
									"pm.test(\"Comment deletion verification\", () => {\r",
									"    const commentId = pm.environment.get(\"parent_comment_id\");\r",
									"    \r",
									"    if (responseCode === 404) {\r",
									"        try {\r",
									"            const responseJson = pm.response.json();\r",
									"            if (responseJson.err === \"Route not found\" && responseJson.ECODE === \"APP_001\") {\r",
									"                console.log(`Comment ${commentId} confirmed deleted (ClickUp 404 + error)`);\r",
									"                pm.expect(responseJson.err).to.equal(\"Route not found\");\r",
									"                pm.expect(responseJson.ECODE).to.equal(\"APP_001\");\r",
									"            } else {\r",
									"                console.log(`Comment ${commentId} confirmed deleted (404 Not Found)`);\r",
									"                pm.expect(responseCode).to.equal(404);\r",
									"            }\r",
									"        } catch (e) {\r",
									"            console.log(`Comment ${commentId} confirmed deleted (404 Not Found)`);\r",
									"            pm.expect(responseCode).to.equal(404);\r",
									"        }\r",
									"        \r",
									"    } else if (responseCode === 410) {\r",
									"        console.log(`Comment ${commentId} confirmed deleted (410 Gone)`);\r",
									"        pm.expect(responseCode).to.equal(410);\r",
									"        \r",
									"    } else if (responseCode === 200) {\r",
									"        console.log(`Comment ${commentId} still exists - deletion failed`);\r",
									"        pm.expect.fail(`Comment deletion failed: received 200 OK, expected 404 for deleted resource`);\r",
									"        \r",
									"    } else {\r",
									"        pm.expect.fail(`Unexpected response code: ${responseCode}. Expected 404 for deleted resource`);\r",
									"    }\r",
									"    \r",
									"    pm.environment.set(\"deletion_verified\", \"true\");\r",
									"    pm.environment.set(\"deletion_verification_method\", responseCode.toString());\r",
									"});\r",
									"\r",
									"pm.test(\"Deletion verification performance\", () => {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(2000);\r",
									"    console.log(`Verification completed in: ${pm.response.responseTime}ms`);\r",
									"});\r",
									"\r",
									"pm.test(\"Response format is valid\", () => {\r",
									"    pm.expect(responseBody).to.be.a('string');\r",
									"    pm.expect(responseBody.length).to.be.above(0);\r",
									"    \r",
									"    if (responseCode === 404 || responseCode === 410) {\r",
									"        try {\r",
									"            const responseJson = pm.response.json();\r",
									"            pm.expect(responseJson).to.be.an('object');\r",
									"        } catch (e) {\r",
									"            console.log(`${responseCode} response has no JSON body (acceptable)`);\r",
									"        }\r",
									"    } else {\r",
									"        console.log(`Invalid response code ${responseCode} detected`);\r",
									"    }\r",
									"    \r",
									"    console.log(`Response format: ${responseCode} with ${responseBody.length} bytes`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{clickupBaseUrl}}/comment/{{second_comment_id}}",
							"host": [
								"{{clickupBaseUrl}}"
							],
							"path": [
								"comment",
								"{{second_comment_id}}"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"auth": {
		"type": "apikey",
		"apikey": [
			{
				"key": "key",
				"value": "Authorization",
				"type": "string"
			},
			{
				"key": "value",
				"value": "{{clickUpApiToken}}",
				"type": "string"
			}
		]
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"// ==================== FOLDER VALIDATION FUNCTIONS ====================\r",
					"\r",
					"pm.collectionVariables.set(\"validateClickUpFolder\", `\r",
					"function validateClickUpFolder(responseJson) {\r",
					"    console.log(\"Validating ClickUp folder response structure...\");\r",
					"    console.log(\"Available fields:\", Object.keys(responseJson));\r",
					"    \r",
					"    pm.test(\"Folder has ID\", () => {\r",
					"        pm.expect(responseJson).to.have.property('id');\r",
					"        pm.expect(responseJson.id).to.be.a('string');\r",
					"        pm.expect(responseJson.id.length).to.be.above(5);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folder has Name\", () => {\r",
					"        pm.expect(responseJson).to.have.property('name');\r",
					"        pm.expect(responseJson.name).to.be.a('string');\r",
					"        pm.expect(responseJson.name.length).to.be.above(0);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folder belongs to correct space\", () => {\r",
					"        pm.expect(responseJson).to.have.property('space');\r",
					"        pm.expect(responseJson.space).to.have.property('id');\r",
					"        pm.expect(responseJson.space.id).to.eql(pm.environment.get(\"spaceId\"));\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folder has creation date\", () => {\r",
					"        if (responseJson.date_created) {\r",
					"            pm.expect(responseJson.date_created).to.be.a('string');\r",
					"            const createdDate = new Date(parseInt(responseJson.date_created));\r",
					"            const now = new Date();\r",
					"            const diffMinutes = (now - createdDate) / (1000 * 60);\r",
					"            pm.expect(diffMinutes).to.be.below(30); // \r",
					"        }\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folder deletion status\", () => {\r",
					"        if (responseJson.hasOwnProperty('deleted')) {\r",
					"            pm.expect(responseJson.deleted).to.be.a('boolean');\r",
					"        }\r",
					"    });\r",
					"    \r",
					"    console.log(\"Folder validation completed for ID:\", responseJson.id);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateFolderArray\", `\r",
					"function validateFolderArray(responseJson) {\r",
					"    console.log(\"Validating folders array response...\");\r",
					"    \r",
					"    pm.test(\"Response has folders property\", () => {\r",
					"        pm.expect(responseJson).to.have.property('folders');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folders is an array\", () => {\r",
					"        pm.expect(responseJson.folders).to.be.an('array');\r",
					"    });\r",
					"    \r",
					"    if (responseJson.folders.length > 0) {\r",
					"        pm.test(\"All folders have basic structure\", () => {\r",
					"            responseJson.folders.forEach((folder, index) => {\r",
					"                pm.expect(folder).to.have.property('id');\r",
					"                pm.expect(folder).to.have.property('name');\r",
					"                pm.expect(folder.id).to.be.a('string');\r",
					"                pm.expect(folder.name).to.be.a('string');\r",
					"            });\r",
					"        });\r",
					"        \r",
					"        pm.test(\"Folders belong to correct space\", () => {\r",
					"            const expectedSpaceId = pm.environment.get(\"spaceId\");\r",
					"            responseJson.folders.forEach((folder) => {\r",
					"                if (folder.space) {\r",
					"                    pm.expect(folder.space.id).to.eql(expectedSpaceId);\r",
					"                }\r",
					"            });\r",
					"        });\r",
					"    }\r",
					"    \r",
					"    console.log(\"Found\", responseJson.folders.length, \"folders in response\");\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateFolderDataMatch\", `\r",
					"function validateFolderDataMatch(responseJson, expectedFolderName) {\r",
					"    pm.test(\"Folder name matches exactly what was sent\", () => {\r",
					"        pm.expect(responseJson.name).to.eql(expectedFolderName);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folder name is not empty\", () => {\r",
					"        pm.expect(responseJson.name.trim()).to.not.be.empty;\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folder name length is reasonable\", () => {\r",
					"        pm.expect(responseJson.name.length).to.be.below(255);\r",
					"        pm.expect(responseJson.name.length).to.be.above(0);\r",
					"    });\r",
					"    \r",
					"    console.log(\"Folder name validation:\", expectedFolderName, \"->\", responseJson.name);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateFolderConsistency\", `\r",
					"function validateFolderConsistency(responseJson, expectedId, expectedName = null) {\r",
					"    pm.test(\"Retrieved folder ID matches expected ID\", () => {\r",
					"        pm.expect(responseJson.id).to.eql(expectedId);\r",
					"    });\r",
					"    \r",
					"    if (expectedName) {\r",
					"        pm.test(\"Retrieved folder name matches expected name\", () => {\r",
					"            pm.expect(responseJson.name).to.eql(expectedName);\r",
					"        });\r",
					"    }\r",
					"    \r",
					"    pm.test(\"Folder structure is consistent\", () => {\r",
					"        pm.expect(responseJson).to.be.an('object');\r",
					"        pm.expect(responseJson).to.have.property('id');\r",
					"        pm.expect(responseJson).to.have.property('name');\r",
					"    });\r",
					"    \r",
					"    console.log(\"Folder consistency check passed for ID:\", expectedId);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateFolderDeletion\", `\r",
					"function validateFolderDeletion(responseJson, deletedFolderId) {\r",
					"    pm.test(\"Deleted folder ID matches\", () => {\r",
					"        pm.expect(responseJson.id).to.eql(deletedFolderId);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Folder is marked as deleted\", () => {\r",
					"        pm.expect(responseJson.deleted).to.be.true;\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Deleted folder still has basic properties\", () => {\r",
					"        pm.expect(responseJson).to.have.property('id');\r",
					"        pm.expect(responseJson).to.have.property('name');\r",
					"    });\r",
					"    \r",
					"    console.log(\"Folder deletion validation passed for ID:\", deletedFolderId);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"logFolderResults\", `\r",
					"function logFolderResults(operation, responseJson, folderType = \"folder\") {\r",
					"    console.log(\"=== \" + operation.toUpperCase() + \" \" + folderType.toUpperCase() + \" TEST RESULTS ===\");\r",
					"    \r",
					"    if (Array.isArray(responseJson)) {\r",
					"        console.log(\"Array Response:\");\r",
					"        console.log(\"- Count:\", responseJson.length);\r",
					"        console.log(\"- Response Time:\", pm.response.responseTime + \"ms\");\r",
					"        \r",
					"        responseJson.forEach((folder, index) => {\r",
					"            console.log(\"Folder \" + (index + 1) + \":\");\r",
					"            console.log(\"  - ID:\", folder.id);\r",
					"            console.log(\"  - Name:\", folder.name);\r",
					"            console.log(\"  - Deleted:\", folder.deleted || false);\r",
					"        });\r",
					"    } else {\r",
					"        console.log(folderType + \":\", operation === \"CREATE\" ? \"created with:\" : \"retrieved/updated:\");\r",
					"        console.log(\"- ID:\", responseJson.id || 'N/A');\r",
					"        console.log(\"- Name:\", responseJson.name || 'N/A');\r",
					"        console.log(\"- Deleted:\", responseJson.deleted || false);\r",
					"        console.log(\"- Response Time:\", pm.response.responseTime + \"ms\");\r",
					"        \r",
					"        if (responseJson.space) {\r",
					"            console.log(\"- Space ID:\", responseJson.space.id);\r",
					"        }\r",
					"    }\r",
					"    \r",
					"    console.log(\"=====================================\");\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"updateFolderVariables\", `\r",
					"function updateFolderVariables(responseJson, operation = \"UNKNOWN\") {\r",
					"    if (responseJson.id) {\r",
					"        pm.collectionVariables.set(\"lastFolderId\", responseJson.id);\r",
					"        \r",
					"        if (operation === \"CREATE\") {\r",
					"            pm.environment.set(\"folderId\", responseJson.id);\r",
					"        } else if (operation === \"CREATE_FOR_DELETION\") {\r",
					"            pm.environment.set(\"deletedFolderId\", responseJson.id);\r",
					"        }\r",
					"    }\r",
					"    \r",
					"    if (responseJson.name) {\r",
					"        pm.collectionVariables.set(\"lastFolderName\", responseJson.name);\r",
					"        \r",
					"        if (operation === \"CREATE\") {\r",
					"            pm.environment.set(\"folderName\", responseJson.name);\r",
					"        } else if (operation === \"CREATE_FOR_DELETION\") {\r",
					"            pm.environment.set(\"deletedFolderName\", responseJson.name);\r",
					"        } else if (operation === \"UPDATE\") {\r",
					"            pm.environment.set(\"updatedFolderName\", responseJson.name);\r",
					"        }\r",
					"    }\r",
					"    \r",
					"    pm.collectionVariables.set(\"lastFolderStatusCode\", pm.response.code);\r",
					"    pm.collectionVariables.set(\"lastFolderResponseTime\", pm.response.responseTime);\r",
					"    \r",
					"    console.log(\"Folder variables updated for operation:\", operation);\r",
					"}\r",
					"`);\r",
					"\r",
					"// ==================== LIST VALIDATION FUNCTIONS ====================\r",
					"\r",
					"pm.collectionVariables.set(\"validateBasicResponse\", `\r",
					"function validateBasicResponse() {\r",
					"    pm.test(\"Status code is 200\", () => {\r",
					"        pm.response.to.have.status(200);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Response time is less than 3000ms\", () => {\r",
					"        pm.expect(pm.response.responseTime).to.be.below(3000);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Response has correct Content-Type\", () => {\r",
					"        pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\r",
					"    });\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateClickUpList\", `\r",
					"function validateClickUpList(responseJson) {\r",
					"    console.log(\"Validating ClickUp list response structure...\");\r",
					"    console.log(\"Available fields:\", Object.keys(responseJson));\r",
					"    \r",
					"    pm.test(\"List has ID\", () => {\r",
					"        pm.expect(responseJson).to.have.property('id');\r",
					"        pm.expect(responseJson.id).to.be.a('string');\r",
					"        pm.expect(responseJson.id.length).to.be.above(5);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"List has Name\", () => {\r",
					"        pm.expect(responseJson).to.have.property('name');\r",
					"        pm.expect(responseJson.name).to.be.a('string');\r",
					"        pm.expect(responseJson.name.length).to.be.above(0);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"List belongs to correct space\", () => {\r",
					"        pm.expect(responseJson).to.have.property('space');\r",
					"        pm.expect(responseJson.space).to.have.property('id');\r",
					"        pm.expect(responseJson.space.id).to.eql(pm.environment.get(\"spaceId\"));\r",
					"    });\r",
					"    \r",
					"    console.log(\"List validation completed for ID:\", responseJson.id);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateListArray\", `\r",
					"function validateListArray(responseJson) {\r",
					"    console.log(\"Validating lists array response...\");\r",
					"    \r",
					"    pm.test(\"Response has lists property\", () => {\r",
					"        pm.expect(responseJson).to.have.property('lists');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Lists is an array\", () => {\r",
					"        pm.expect(responseJson.lists).to.be.an('array');\r",
					"    });\r",
					"    \r",
					"    if (responseJson.lists.length > 0) {\r",
					"        pm.test(\"All lists have basic structure\", () => {\r",
					"            responseJson.lists.forEach((list, index) => {\r",
					"                pm.expect(list).to.have.property('id');\r",
					"                pm.expect(list).to.have.property('name');\r",
					"                pm.expect(list.id).to.be.a('string');\r",
					"                pm.expect(list.name).to.be.a('string');\r",
					"            });\r",
					"        });\r",
					"    }\r",
					"    \r",
					"    console.log(\"Found\", responseJson.lists.length, \"lists in response\");\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateListDataMatch\", `\r",
					"function validateListDataMatch(responseJson, expectedListName) {\r",
					"    pm.test(\"List name matches exactly what was sent\", () => {\r",
					"        pm.expect(responseJson.name).to.eql(expectedListName);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"List name is not empty\", () => {\r",
					"        pm.expect(responseJson.name.trim()).to.not.be.empty;\r",
					"    });\r",
					"    \r",
					"    console.log(\"List name validation:\", expectedListName, \"->\", responseJson.name);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateListConsistency\", `\r",
					"function validateListConsistency(responseJson, expectedId, expectedName = null) {\r",
					"    pm.test(\"Retrieved list ID matches expected ID\", () => {\r",
					"        pm.expect(responseJson.id).to.eql(expectedId);\r",
					"    });\r",
					"    \r",
					"    if (expectedName) {\r",
					"        pm.test(\"Retrieved list name matches expected name\", () => {\r",
					"            pm.expect(responseJson.name).to.eql(expectedName);\r",
					"        });\r",
					"    }\r",
					"    \r",
					"    console.log(\"List consistency check passed for ID:\", expectedId);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateListDeletion\", `\r",
					"function validateListDeletion(responseJson, deletedListId) {\r",
					"    pm.test(\"Deleted list ID matches\", () => {\r",
					"        pm.expect(responseJson.id).to.eql(deletedListId);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"List is marked as deleted or archived\", () => {\r",
					"        if (responseJson.hasOwnProperty('deleted')) {\r",
					"            pm.expect(responseJson.deleted).to.be.true;\r",
					"        } else if (responseJson.hasOwnProperty('archived')) {\r",
					"            pm.expect(responseJson.archived).to.be.true;\r",
					"        }\r",
					"    });\r",
					"    \r",
					"    console.log(\"List deletion validation passed for ID:\", deletedListId);\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"logListResults\", `\r",
					"function logListResults(operation, responseJson, listType = \"list\") {\r",
					"    console.log(\"=== \" + operation.toUpperCase() + \" \" + listType.toUpperCase() + \" TEST RESULTS ===\");\r",
					"    \r",
					"    if (Array.isArray(responseJson)) {\r",
					"        console.log(\"Array Response:\");\r",
					"        console.log(\"- Count:\", responseJson.length);\r",
					"        console.log(\"- Response Time:\", pm.response.responseTime + \"ms\");\r",
					"        \r",
					"        responseJson.forEach((list, index) => {\r",
					"            console.log(\"List \" + (index + 1) + \":\");\r",
					"            console.log(\"  - ID:\", list.id);\r",
					"            console.log(\"  - Name:\", list.name);\r",
					"            console.log(\"  - Folder:\", list.folder ? list.folder.name : \"Folderless\");\r",
					"        });\r",
					"    } else {\r",
					"        console.log(listType + \":\", operation === \"CREATE\" ? \"created with:\" : \"retrieved/updated:\");\r",
					"        console.log(\"- ID:\", responseJson.id || 'N/A');\r",
					"        console.log(\"- Name:\", responseJson.name || 'N/A');\r",
					"        console.log(\"- Folder:\", responseJson.folder ? responseJson.folder.name : \"Folderless\");\r",
					"        console.log(\"- Response Time:\", pm.response.responseTime + \"ms\");\r",
					"    }\r",
					"    \r",
					"    console.log(\"=====================================\");\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"updateListVariables\", `\r",
					"function updateListVariables(responseJson, operation = \"UNKNOWN\") {\r",
					"    if (responseJson.id) {\r",
					"        pm.collectionVariables.set(\"lastListId\", responseJson.id);\r",
					"        \r",
					"        if (operation === \"CREATE\") {\r",
					"            pm.environment.set(\"folderlessListId\", responseJson.id);\r",
					"        } else if (operation === \"CREATE_FOR_DELETION\") {\r",
					"            pm.environment.set(\"deletedFolderlessListId\", responseJson.id);\r",
					"        }\r",
					"    }\r",
					"    \r",
					"    if (responseJson.name) {\r",
					"        pm.collectionVariables.set(\"lastListName\", responseJson.name);\r",
					"    }\r",
					"    \r",
					"    pm.collectionVariables.set(\"lastListStatusCode\", pm.response.code);\r",
					"    pm.collectionVariables.set(\"lastListResponseTime\", pm.response.responseTime);\r",
					"    \r",
					"    console.log(\"List variables updated for operation:\", operation);\r",
					"}\r",
					"`);\r",
					"\r",
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					"pm.collectionVariables.set(\"validateClickUpTask\", `\r",
					"function validateClickUpTask(responseJson) {\r",
					"    pm.test(\"Task has ID\", () => {\r",
					"        pm.expect(responseJson).to.have.property('id');\r",
					"        pm.expect(responseJson.id).to.be.a('string');\r",
					"        pm.expect(responseJson.id).to.match(/^[a-zA-Z0-9]+$/);\r",
					"        pm.expect(responseJson.id.length).to.be.above(5);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task has Name\", () => {\r",
					"        pm.expect(responseJson).to.have.property('name');\r",
					"        pm.expect(responseJson.name).to.be.a('string');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task has Description\", () => {\r",
					"        pm.expect(responseJson).to.have.property('description');\r",
					"        pm.expect(responseJson.description).to.be.a('string');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task Priority is valid\", () => {\r",
					"        pm.expect(responseJson).to.have.property('priority');\r",
					"        pm.expect(responseJson.priority).to.be.an('object');\r",
					"        pm.expect(responseJson.priority).to.have.property('id');\r",
					"        pm.expect(responseJson.priority).to.have.property('color');\r",
					"        pm.expect(responseJson.priority).to.have.property('priority');\r",
					"    });\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateBasicResponse\", `\r",
					"function validateBasicResponse() {\r",
					"    pm.test(\"Status code is 200\", () => {\r",
					"        pm.response.to.have.status(200);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Response time is less than 2000ms\", () => {\r",
					"        pm.expect(pm.response.responseTime).to.be.below(2000);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Response has correct Content-Type\", () => {\r",
					"        pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\r",
					"    });\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateTaskDataMatch\", `\r",
					"function validateTaskDataMatch(responseJson) {\r",
					"    pm.test(\"Task name matches exactly what was sent\", () => {\r",
					"        const expectedName = pm.environment.get(\"task_numeric_name\");\r",
					"        const actualName = responseJson.name;\r",
					"        pm.expect(actualName).to.eql(expectedName);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task description matches what was sent\", () => {\r",
					"        const expectedDescription = pm.environment.get(\"long_description\");\r",
					"        const actualDescription = responseJson.description;\r",
					"        \r",
					"        pm.expect(actualDescription).to.include(expectedDescription.substring(0, 200));\r",
					"        pm.expect(actualDescription.length).to.be.closeTo(expectedDescription.length, 5);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task priority matches what was sent\", () => {\r",
					"        const expectedPriority = pm.environment.get(\"expected_priority\").toString();\r",
					"        const actualPriority = responseJson.priority;\r",
					"        \r",
					"        pm.expect(actualPriority).to.be.an('object');\r",
					"        pm.expect(actualPriority).to.have.property('id');\r",
					"        pm.expect(actualPriority.id).to.eql(expectedPriority);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task priority is within valid range (1-3)\", () => {\r",
					"        const actualPriority = responseJson.priority;\r",
					"        const priorityValue = parseInt(actualPriority.id);\r",
					"        pm.expect(priorityValue).to.be.at.least(1).and.at.most(3);\r",
					"    });\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateTaskQuality\", `\r",
					"function validateTaskQuality(responseJson) {\r",
					"    pm.test(\"Description meets minimum length requirement (1000+ characters)\", () => {\r",
					"        const actualDescription = responseJson.description;\r",
					"        pm.expect(actualDescription).to.not.be.empty;\r",
					"        pm.expect(actualDescription.length).to.be.above(1000);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Description does not contain suspicious content\", () => {\r",
					"        const actualDescription = responseJson.description;\r",
					"        const suspiciousPatterns = ['<script', 'javascript:', 'eval(', 'onclick='];\r",
					"        \r",
					"        suspiciousPatterns.forEach(pattern => {\r",
					"            pm.expect(actualDescription.toLowerCase()).to.not.include(pattern.toLowerCase());\r",
					"        });\r",
					"    });\r",
					"}\r",
					"`);\r",
					"\r",
					"// Validation functions for GET (additional ClickUp metadata)\r",
					"pm.collectionVariables.set(\"validateClickUpMetadata\", `\r",
					"function validateClickUpMetadata(responseJson) {\r",
					"    pm.test(\"Task has ClickUp status metadata\", () => {\r",
					"        pm.expect(responseJson).to.have.property('status');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task has creator information\", () => {\r",
					"        pm.expect(responseJson).to.have.property('creator');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task has creation timestamp\", () => {\r",
					"        pm.expect(responseJson).to.have.property('date_created');\r",
					"        pm.expect(responseJson.date_created).to.be.a('string');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task creation timestamp is within acceptable range\", () => {\r",
					"        const createdDate = new Date(parseInt(responseJson.date_created));\r",
					"        const now = new Date();\r",
					"        const diffMinutes = (now - createdDate) / (1000 * 60);\r",
					"        pm.expect(diffMinutes).to.be.below(10);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Task belongs to correct list\", () => {\r",
					"        const list = responseJson.list;\r",
					"        pm.expect(list).to.be.an('object');\r",
					"        pm.expect(list).to.have.property('id');\r",
					"\r",
					"        const expectedListId = pm.environment.get(\"template_list_id\");\r",
					"        pm.expect(list.id).to.eql(expectedListId);\r",
					"    });\r",
					"}\r",
					"`);\r",
					"// Validation functions for GET (checking consistency with the created task)\r",
					"pm.collectionVariables.set(\"validateTaskConsistency\", `\r",
					"function validateTaskConsistency(responseJson) {\r",
					"    pm.test(\"Retrieved task ID matches requested ID\", () => {\r",
					"        const expectedTaskId = pm.environment.get(\"task_id\");\r",
					"        const actualTaskId = responseJson.id;\r",
					"        pm.expect(actualTaskId).to.eql(expectedTaskId);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Retrieved task name matches created task\", () => {\r",
					"        const expectedName = pm.environment.get(\"task_numeric_name\");\r",
					"        const actualName = responseJson.name;\r",
					"        pm.expect(actualName).to.eql(expectedName);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Retrieved task description matches created task\", () => {\r",
					"        const expectedDescription = pm.environment.get(\"long_description\");\r",
					"        const actualDescription = responseJson.description;\r",
					"        \r",
					"        pm.expect(actualDescription).to.include(expectedDescription.substring(0, 200));\r",
					"        pm.expect(actualDescription.length).to.be.closeTo(expectedDescription.length, 5);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Retrieved task priority matches created task\", () => {\r",
					"        const expectedPriority = pm.environment.get(\"expected_priority\").toString();\r",
					"        const actualPriority = responseJson.priority;\r",
					"        \r",
					"        pm.expect(actualPriority).to.be.an('object');\r",
					"        pm.expect(actualPriority).to.have.property('id');\r",
					"        pm.expect(actualPriority.id).to.eql(expectedPriority);\r",
					"    });\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"updateCollectionVariables\", `\r",
					"function updateCollectionVariables(responseJson) {\r",
					"    pm.collectionVariables.set(\"lastStatusCode\", pm.response.code);\r",
					"    pm.collectionVariables.set(\"lastResponseTime\", pm.response.responseTime);\r",
					"    pm.collectionVariables.set(\"task_id\", responseJson.id);\r",
					"    pm.collectionVariables.set(\"task_name\", responseJson.name);\r",
					"    pm.collectionVariables.set(\"task_description\", responseJson.description);\r",
					"    pm.collectionVariables.set(\"task_priority\", responseJson.priority.id);\r",
					"    \r",
					"    if (responseJson.list) {\r",
					"        pm.collectionVariables.set(\"list_id\", responseJson.list.id);\r",
					"    }\r",
					"}\r",
					"`);\r",
					"\r",
					"// ==================== COMMENT VALIDATION FUNCTIONS ====================\r",
					"\r",
					"pm.collectionVariables.set(\"validateClickUpComment\", `\r",
					"function validateClickUpComment(responseJson) {\r",
					"    console.log(\"Validating ClickUp comment response structure...\");\r",
					"    console.log(\"Available fields:\", Object.keys(responseJson));\r",
					"    \r",
					"    pm.test(\"Comment has ID\", () => {\r",
					"        pm.expect(responseJson).to.have.property('id');\r",
					"        pm.expect(responseJson.id).to.be.a('number');\r",
					"        pm.expect(responseJson.id.toString().length).to.be.above(5);\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Comment has text content\", () => {\r",
					"        const textFields = ['comment', 'comment_text', 'text', 'content', 'body'];\r",
					"        const hasText = textFields.some(field => responseJson.hasOwnProperty(field));\r",
					"        \r",
					"        if (hasText) {\r",
					"            const commentText = responseJson.comment || responseJson.comment_text || responseJson.text || responseJson.content || responseJson.body;\r",
					"            pm.expect(commentText).to.be.a('string');\r",
					"            pm.expect(commentText.length).to.be.above(0);\r",
					"        } else {\r",
					"            console.log(\"Text field not found in comment response\");\r",
					"        }\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Comment has user information\", () => {\r",
					"        const userFields = ['user', 'creator', 'author', 'created_by'];\r",
					"        const hasUser = userFields.some(field => responseJson.hasOwnProperty(field));\r",
					"        \r",
					"        if (hasUser) {\r",
					"            const user = responseJson.user || responseJson.creator || responseJson.author || responseJson.created_by;\r",
					"            pm.expect(user).to.be.an('object');\r",
					"            pm.expect(user).to.have.property('id');\r",
					"            pm.expect(user).to.have.property('username');\r",
					"        } else {\r",
					"            console.log(\"User field not found in comment response\");\r",
					"        }\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Comment has creation date\", () => {\r",
					"        const dateFields = ['date', 'date_created', 'created_at', 'timestamp'];\r",
					"        const hasDate = dateFields.some(field => responseJson.hasOwnProperty(field));\r",
					"        \r",
					"        if (hasDate) {\r",
					"            const date = responseJson.date || responseJson.date_created || responseJson.created_at || responseJson.timestamp;\r",
					"            pm.expect(date).to.be.a('number');\r",
					"            pm.expect(date).to.be.above(0);\r",
					"        } else {\r",
					"            console.log(\"Date field not found in comment response\");\r",
					"        }\r",
					"    });\r",
					"    \r",
					"    console.log(\"Actual comment response structure:\", JSON.stringify(responseJson, null, 2));\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateCommentDataMatch\", `\r",
					"function validateCommentDataMatch(responseJson, expectedText, expectedAssigneeId = null) {\r",
					"\r",
					"    const commentText = responseJson.comment || responseJson.comment_text || responseJson.text || responseJson.content || responseJson.body;\r",
					"    \r",
					"    pm.test(\"Comment text matches exactly what was sent\", () => {\r",
					"        pm.expect(commentText).to.eql(expectedText);\r",
					"    });\r",
					"    \r",
					"    if (expectedAssigneeId) {\r",
					"        pm.test(\"Comment assignee matches what was sent\", () => {\r",
					"            const assignee = responseJson.assignee || responseJson.assigned_to || responseJson.assigned_user;\r",
					"            if (assignee) {\r",
					"                pm.expect(assignee.id.toString()).to.eql(expectedAssigneeId.toString());\r",
					"            } else {\r",
					"                console.log(\"Assignee information not available in response\");\r",
					"            }\r",
					"        });\r",
					"    }\r",
					"    \r",
					"    pm.test(\"Comment resolved status is correct\", () => {\r",
					"        if (responseJson.resolved !== undefined) {\r",
					"            pm.expect(responseJson.resolved).to.be.a('boolean');\r",
					"        } else {\r",
					"            console.log(\"Resolution status not available in response\");\r",
					"        }\r",
					"    });\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateCommentArray\", `\r",
					"function validateCommentArray(commentsArray, expectedMinCount = 0) {\r",
					"    pm.test(\"Response contains comments array\", () => {\r",
					"        pm.expect(commentsArray).to.be.an('array');\r",
					"    });\r",
					"    \r",
					"    pm.test(\"Array contains expected minimum number of comments\", () => {\r",
					"        pm.expect(commentsArray.length).to.be.at.least(expectedMinCount);\r",
					"    });\r",
					"    \r",
					"    if (commentsArray.length > 0) {\r",
					"        pm.test(\"All array items have basic comment structure\", () => {\r",
					"            commentsArray.forEach((comment, index) => {\r",
					"                pm.expect(comment).to.have.property('id');\r",
					"                \r",
					"                const textFields = ['comment', 'comment_text', 'text', 'content', 'body'];\r",
					"                const hasText = textFields.some(field => comment.hasOwnProperty(field));\r",
					"                pm.expect(hasText).to.be.true;\r",
					"            });\r",
					"        });\r",
					"    }\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"validateThreadedComment\", `\r",
					"function validateThreadedComment(responseJson, expectedParentId = null) {\r",
					"    eval(pm.collectionVariables.get(\"validateClickUpComment\"));\r",
					"    validateClickUpComment(responseJson);\r",
					"    \r",
					"    if (expectedParentId) {\r",
					"        pm.test(\"Threaded comment has correct parent ID\", () => {\r",
					"            pm.expect(responseJson).to.have.property('parent');\r",
					"            pm.expect(responseJson.parent.toString()).to.eql(expectedParentId.toString());\r",
					"        });\r",
					"    }\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"getCommentText\", `\r",
					"function getCommentText(comment) {\r",
					"    const text = comment.comment || comment.comment_text || comment.text || comment.content || comment.body;\r",
					"    \r",
					"    if (Array.isArray(text)) {\r",
					"        return text[0]; // ClickUp czasami zwraca array\r",
					"    }\r",
					"    return text; // String lub undefined\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"logCommentResults\", `\r",
					"function logCommentResults(operation, responseJson, commentType = \"comment\") {\r",
					"    console.log(\"=== \" + operation.toUpperCase() + \" \" + commentType.toUpperCase() + \" TEST RESULTS ===\");\r",
					"    \r",
					"    if (Array.isArray(responseJson)) {\r",
					"        console.log(\"Array Response:\");\r",
					"        console.log(\"- Count:\", responseJson.length);\r",
					"        console.log(\"- Response Time:\", pm.response.responseTime + \"ms\");\r",
					"        \r",
					"        responseJson.forEach((comment, index) => {\r",
					"            const commentText = comment.comment || comment.comment_text || comment.text || comment.content || comment.body || \"N/A\";\r",
					"            const user = comment.user || comment.creator || comment.author || comment.created_by || { username: \"Unknown\" };\r",
					"            \r",
					"            console.log(\"Comment \" + (index + 1) + \":\");\r",
					"            console.log(\"  - ID:\", comment.id);\r",
					"            \r",
					"            if (typeof commentText === 'string' && commentText !== \"N/A\") {\r",
					"                console.log(\"  - Text Preview:\", commentText.substring(0, 50) + \"...\");\r",
					"            } else {\r",
					"                console.log(\"  - Text Preview:\", \"N/A\");\r",
					"            }\r",
					"            \r",
					"            console.log(\"  - User:\", user.username);\r",
					"            console.log(\"  - Resolved:\", comment.resolved || false);\r",
					"        });\r",
					"    } else {\r",
					"        const commentText = responseJson.comment || responseJson.comment_text || responseJson.text || responseJson.content || responseJson.body || \"N/A\";\r",
					"        const user = responseJson.user || responseJson.creator || responseJson.author || responseJson.created_by || { username: \"Unknown\" };\r",
					"        const assignee = responseJson.assignee || responseJson.assigned_to || responseJson.assigned_user || { username: \"None\" };\r",
					"        \r",
					"        console.log(commentType + \":\", operation === \"CREATE\" ? \"created with:\" : \"retrieved/updated:\");\r",
					"        console.log(\"- ID:\", responseJson.id || 'N/A');\r",
					"        console.log(\"- Text:\", commentText);\r",
					"        \r",
					"        if (typeof commentText === 'string' && commentText !== \"N/A\") {\r",
					"            console.log(\"- Text Length:\", commentText.length);\r",
					"        } else {\r",
					"            console.log(\"- Text Length:\", 0);\r",
					"        }\r",
					"        \r",
					"        console.log(\"- User:\", user.username);\r",
					"        console.log(\"- Assignee:\", assignee.username);\r",
					"        console.log(\"- Resolved:\", responseJson.resolved || false);\r",
					"        console.log(\"- Response Time:\", pm.response.responseTime + \"ms\");\r",
					"        \r",
					"        if (responseJson.parent) {\r",
					"            console.log(\"- Parent ID:\", responseJson.parent);\r",
					"        }\r",
					"    }\r",
					"    \r",
					"    console.log(\"=====================================\");\r",
					"}\r",
					"`);\r",
					"\r",
					"pm.collectionVariables.set(\"updateCommentVariables\", `\r",
					"function updateCommentVariables(responseJson) {\r",
					"    if (responseJson.id) {\r",
					"        pm.environment.set(\"last_comment_id\", responseJson.id.toString());\r",
					"    }\r",
					"    \r",
					"    const commentText = responseJson.comment || responseJson.comment_text || responseJson.text || responseJson.content || responseJson.body;\r",
					"    if (commentText) {\r",
					"        pm.environment.set(\"last_comment_text\", commentText);\r",
					"    }\r",
					"    \r",
					"    // Store resolution status\r",
					"    if (responseJson.resolved !== undefined) {\r",
					"        pm.environment.set(\"last_comment_resolved\", responseJson.resolved.toString());\r",
					"    }\r",
					"    \r",
					"    console.log(\"Comment variables updated successfully\");\r",
					"}\r",
					"`);\r",
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "validateClickUpTask",
			"value": ""
		},
		{
			"key": "validateBasicResponse",
			"value": ""
		},
		{
			"key": "validateTaskDataMatch",
			"value": ""
		},
		{
			"key": "validateTaskQuality",
			"value": ""
		},
		{
			"key": "validateClickUpMetadata",
			"value": ""
		},
		{
			"key": "validateTaskConsistency",
			"value": ""
		},
		{
			"key": "updateCollectionVariables",
			"value": ""
		},
		{
			"key": "logTaskResults",
			"value": ""
		},
		{
			"key": "lastStatusCode",
			"value": ""
		},
		{
			"key": "lastResponseTime",
			"value": ""
		},
		{
			"key": "task_id",
			"value": ""
		},
		{
			"key": "task_name",
			"value": ""
		},
		{
			"key": "task_description",
			"value": ""
		},
		{
			"key": "task_priority",
			"value": ""
		},
		{
			"key": "list_id",
			"value": ""
		},
		{
			"key": "validateClickUpComment",
			"value": ""
		},
		{
			"key": "validateCommentDataMatch",
			"value": ""
		},
		{
			"key": "validateThreadedComment",
			"value": ""
		},
		{
			"key": "validateCommentArray",
			"value": ""
		},
		{
			"key": "validateErrorResponse",
			"value": ""
		},
		{
			"key": "logCommentResults",
			"value": ""
		},
		{
			"key": "updateCommentVariables",
			"value": ""
		},
		{
			"key": "validateClickUpFolder",
			"value": ""
		},
		{
			"key": "validateFolderArray",
			"value": ""
		},
		{
			"key": "validateFolderDataMatch",
			"value": ""
		},
		{
			"key": "validateFolderConsistency",
			"value": ""
		},
		{
			"key": "validateFolderDeletion",
			"value": ""
		},
		{
			"key": "logFolderResults",
			"value": ""
		},
		{
			"key": "updateFolderVariables",
			"value": ""
		},
		{
			"key": "lastFolderId",
			"value": ""
		},
		{
			"key": "lastFolderName",
			"value": ""
		},
		{
			"key": "lastFolderStatusCode",
			"value": ""
		},
		{
			"key": "lastFolderResponseTime",
			"value": ""
		},
		{
			"key": "getCommentText",
			"value": ""
		},
		{
			"key": "validateClickUpList",
			"value": ""
		},
		{
			"key": "validateListArray",
			"value": ""
		},
		{
			"key": "validateListDataMatch",
			"value": ""
		},
		{
			"key": "validateListConsistency",
			"value": ""
		},
		{
			"key": "validateListDeletion",
			"value": ""
		},
		{
			"key": "logListResults",
			"value": ""
		},
		{
			"key": "updateListVariables",
			"value": ""
		},
		{
			"key": "lastListId",
			"value": ""
		},
		{
			"key": "lastListName",
			"value": ""
		},
		{
			"key": "lastListStatusCode",
			"value": ""
		},
		{
			"key": "lastListResponseTime",
			"value": ""
		},
		{
			"key": "exampleFolderlessListId",
			"value": ""
		},
		{
			"key": "testListId",
			"value": ""
		}
	]
}