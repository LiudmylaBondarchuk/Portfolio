{
	"info": {
		"_postman_id": "0bbfd7e5-a48b-45c0-89d5-92e3702d094e",
		"name": "Jira Cloud API Tests",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "45512473"
	},
	"item": [
		{
			"name": "Basic CRUD Tests",
			"item": [
				{
					"name": "Authentication & Setup",
					"item": [
						{
							"name": "Setup Auth Token",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const email = pm.environment.get(\"jiraEmail\");\r",
											"const token = pm.environment.get(\"jiraApiToken\");\r",
											"const authString = btoa(`${email}:${token}`);\r",
											"pm.environment.set(\"authBasic\", `Basic ${authString}`);\r",
											"pm.environment.set('defaultProjectTemplate', 'com.pyxis.greenhopper.jira:gh-simplified-agility-kanban');\r",
											"pm.environment.set('businessProjectTemplate', 'com.atlassian.jira-core-project-templates:jira-core-task-management');"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"const jsonData = pm.response.json();\r",
											"pm.environment.set('currentUserAccountId', jsonData.accountId);\r",
											"pm.environment.set('currentUserEmail', jsonData.emailAddress);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/myself",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"myself"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Projects",
					"item": [
						{
							"name": "Create Project",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Project Created Successfully', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const project = pm.response.json();\r",
											"    pm.expect(project).to.have.property('id');\r",
											"    pm.expect(project).to.have.property('key'); \r",
											"    pm.expect(project).to.have.property('self');\r",
											"    \r",
											"    pm.expect(project.key).to.eql(pm.environment.get('testProjectKey'));\r",
											"    pm.expect(project.id).to.exist;\r",
											"    pm.expect(project.key).to.be.a('string').and.not.be.empty;\r",
											"    pm.expect(project.self).to.be.a('string').and.match(/^https?:\\/\\/.+\\/rest\\/api\\/3\\/project\\/\\d+$/);\r",
											"    \r",
											"    pm.environment.set('createdProjectId', project.id);\r",
											"    pm.environment.set('createdProjectKey', project.key);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const randomNum = Math.floor(Math.random() * 10000);\r",
											"const timestamp = Date.now();\r",
											"\r",
											"pm.environment.set('testProjectKey', `TEST${randomNum}`);\r",
											"pm.environment.set('testProjectName', `Test Project ${randomNum}`);\r",
											"pm.environment.set('testProjectDescription', `Automated test project ${timestamp}`);\r",
											"pm.environment.set('projectType', pm.environment.get('projectType') || 'software');\r",
											"pm.environment.set('projectAvatarId', pm.environment.get('projectAvatarId') || '10200');\r",
											"\r",
											"const requiredVars = ['jiraBaseUrl', 'currentUserAccountId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"{{testProjectKey}}\",\r\n    \"name\": \"{{testProjectName}}\",\r\n    \"description\": \"{{testProjectDescription}}\",\r\n    \"projectTypeKey\": \"{{projectType}}\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"PROJECT_LEAD\",\r\n    \"avatarId\": \"{{projectAvatarId}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Project for Delete",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Delete test project created successfully', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(10000);\r",
											"    \r",
											"    const project = pm.response.json();\r",
											"    pm.expect(project).to.have.property('id');\r",
											"    pm.expect(project).to.have.property('key');\r",
											"    pm.expect(project).to.have.property('self');\r",
											"    \r",
											"    pm.environment.set('projectToDeleteId', project.id);\r",
											"    pm.environment.set('projectToDeleteKey', project.key);  \r",
											"    const baseUrl = pm.environment.get('jiraBaseUrl');\r",
											"    pm.environment.set('projectDeleteUrl', `${baseUrl}/rest/api/3/project/${project.key}`);\r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const timestamp = Date.now();\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"\r",
											"pm.environment.set('deleteProjectKey', `DEL${randomNum}`);\r",
											"pm.environment.set('deleteProjectName', `DELETE Test Project ${randomNum}`);\r",
											"pm.environment.set('deleteProjectDescription', `Project for DELETE testing - ${timestamp}`);\r",
											"pm.environment.set('deleteProjectType', 'business');"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"{{deleteProjectKey}}\",\r\n    \"name\": \"{{deleteProjectName}}\",\r\n    \"description\": \"{{deleteProjectDescription}}\",\r\n    \"projectTypeKey\": \"{{deleteProjectType}}\",\r\n    \"projectTemplateKey\": \"{{businessProjectTemplate}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"UNASSIGNED\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get All Projects",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Projects retrieved and test projects identified', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(8000);\r",
											"    \r",
											"    const projects = pm.response.json();\r",
											"    pm.expect(projects).to.be.an('array');\r",
											"    pm.expect(projects.length).to.be.greaterThan(0);\r",
											"    \r",
											"    const testProjectPatterns = /^(TEST|JQL|DEL|NEGATIVE|EMJ)/i;\r",
											"    let testProjectIds = [];\r",
											"    \r",
											"    projects.forEach((project, index) => {\r",
											"        pm.expect(project, `Project ${index} missing id`).to.have.property('id');\r",
											"        pm.expect(project, `Project ${index} missing key`).to.have.property('key');\r",
											"        pm.expect(project, `Project ${index} missing name`).to.have.property('name');\r",
											"        \r",
											"        const isTestProject = testProjectPatterns.test(project.key) || \r",
											"                             project.name.toLowerCase().includes('test');\r",
											"        \r",
											"        if (isTestProject) {\r",
											"            testProjectIds.push({\r",
											"                id: project.id,\r",
											"                key: project.key,\r",
											"                name: project.name\r",
											"            });\r",
											"        }\r",
											"    });\r",
											"    \r",
											"    pm.environment.set('totalProjectsCount', projects.length);\r",
											"    pm.environment.set('testProjectIds', JSON.stringify(testProjectIds));\r",
											"    pm.environment.set('testProjectsCount', testProjectIds.length);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Project",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const timestamp = Date.now();\r",
											"const randomNum = Math.floor(Math.random() * 10000);\r",
											"const projectToUpdate = pm.environment.get('createdProjectKey');\r",
											"\r",
											"if (!projectToUpdate) {\r",
											"    throw new Error('No project found to update. Run CREATE project request first.');\r",
											"}\r",
											"\r",
											"pm.environment.set('updatedProjectKey', projectToUpdate); \r",
											"pm.environment.set('updatedProjectName', `Updated Test Project ${randomNum}`);\r",
											"pm.environment.set('updatedProjectDescription', `UPDATED: Automated test project updated on ${new Date().toISOString()}`);\r",
											"pm.environment.set('updatedAssigneeType', 'UNASSIGNED');\r",
											"pm.environment.set('updatedProjectAvatarId', '10201');"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Project updated successfully', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(7000);\r",
											"    \r",
											"    const project = pm.response.json();\r",
											"    pm.expect(project).to.have.property('id');\r",
											"    pm.expect(project).to.have.property('key');\r",
											"    pm.expect(project).to.have.property('name');\r",
											"    \r",
											"    pm.expect(project.name).to.eql(pm.environment.get('updatedProjectName'));\r",
											"    pm.expect(project.key).to.eql(pm.environment.get('updatedProjectKey'));\r",
											"    \r",
											"    if (project.description) {\r",
											"        pm.expect(project.description).to.include('UPDATED:');\r",
											"    }\r",
											"    \r",
											"    pm.environment.set('updatedProjectId', project.id);\r",
											"    pm.environment.set('verificationProjectKey', project.key);\r",
											"    pm.environment.set('finalProjectName', project.name);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"{{updatedProjectKey}}\",\r\n    \"name\": \"{{updatedProjectName}}\",\r\n    \"description\": \"{{updatedProjectDescription}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"{{updatedAssigneeType}}\",\r\n    \"avatarId\": \"{{updatedProjectAvatarId}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project/{{createdProjectKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project",
										"{{createdProjectKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Search Projects",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Project updated successfully', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    let project;\r",
											"    \r",
											"    if (response.values) {\r",
											"        pm.expect(response.values).to.be.an('array');\r",
											"        pm.expect(response.values.length).to.be.greaterThan(0);\r",
											"        project = response.values[0];\r",
											"    } else {\r",
											"        project = response;\r",
											"    }\r",
											"    \r",
											"    pm.expect(project).to.have.property('id');\r",
											"    pm.expect(project).to.have.property('key');\r",
											"    pm.expect(project).to.have.property('name');\r",
											"    \r",
											"    pm.expect(project.name).to.eql(pm.environment.get('updatedProjectName'));\r",
											"    pm.expect(project.key).to.eql(pm.environment.get('updatedProjectKey'));\r",
											"    \r",
											"    if (project.description) {\r",
											"        pm.expect(project.description).to.include('UPDATED:');\r",
											"    }\r",
											"    \r",
											"    pm.environment.set('updatedProjectId', project.id);\r",
											"    pm.environment.set('verificationProjectKey', project.key);\r",
											"    pm.environment.set('finalProjectName', project.name);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/project/search?query={{updatedProjectKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "{{updatedProjectKey}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete Project",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Project deletion successful', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(10000);\r",
											"    pm.expect(pm.response.text()).to.be.empty;\r",
											"    \r",
											"    pm.environment.set('projectDeleted', 'true');\r",
											"    pm.environment.set('deletionTimestamp', new Date().toISOString());\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/project/{{projectToDeleteId}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project",
										"{{projectToDeleteId}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Issues",
					"item": [
						{
							"name": "Get Issue Types Metadata",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Issue types metadata retrieved and processed', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    const targetProjectKey = pm.environment.get('updatedProjectKey');\r",
											"    \r",
											"    pm.expect(response).to.have.property('projects');\r",
											"    pm.expect(response.projects).to.be.an('array');\r",
											"    pm.expect(response.projects.length).to.be.greaterThan(0);\r",
											"    \r",
											"    const project = response.projects.find(p => p.key === targetProjectKey);\r",
											"    pm.expect(project, `Project ${targetProjectKey} not found`).to.exist;\r",
											"    pm.expect(project).to.have.property('issuetypes');\r",
											"    pm.expect(project.issuetypes).to.be.an('array');\r",
											"    pm.expect(project.issuetypes.length).to.be.greaterThan(0);\r",
											"    \r",
											"    project.issuetypes.forEach(issueType => {\r",
											"        pm.expect(issueType).to.have.property('id');\r",
											"        pm.expect(issueType).to.have.property('name');\r",
											"        \r",
											"        const typeName = issueType.name.toLowerCase();\r",
											"        \r",
											"        if (typeName === 'task') {\r",
											"            pm.environment.set('taskIssueTypeId', issueType.id);\r",
											"            pm.environment.set('taskIssueTypeName', issueType.name);\r",
											"        }\r",
											"        \r",
											"        if (typeName === 'epic') {\r",
											"            pm.environment.set('epicIssueTypeId', issueType.id);\r",
											"            pm.environment.set('epicIssueTypeName', issueType.name);\r",
											"        }\r",
											"        \r",
											"        if (typeName === 'subtask' || typeName === 'sub-task') {\r",
											"            pm.environment.set('subtaskIssueTypeId', issueType.id);\r",
											"            pm.environment.set('subtaskIssueTypeName', issueType.name);\r",
											"        }\r",
											"    });\r",
											"    \r",
											"    pm.environment.set('defaultIssueTypeId', project.issuetypes[0].id);\r",
											"    pm.environment.set('defaultIssueTypeName', project.issuetypes[0].name);\r",
											"    \r",
											"    pm.expect(pm.environment.get('defaultIssueTypeId')).to.exist;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/createmeta?projectKeys={{updatedProjectKey}}&expand=projects.issuetypes",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"createmeta"
									],
									"query": [
										{
											"key": "projectKeys",
											"value": "{{updatedProjectKey}}"
										},
										{
											"key": "expand",
											"value": "projects.issuetypes"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Epic",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic created and data saved', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const epic = pm.response.json();\r",
											"    pm.expect(epic).to.have.property('id');\r",
											"    pm.expect(epic).to.have.property('key');\r",
											"    pm.expect(epic).to.have.property('self');\r",
											"    \r",
											"    pm.expect(epic.key).to.include(pm.environment.get('updatedProjectKey'));\r",
											"    \r",
											"    pm.environment.set('createdEpicId', epic.id);\r",
											"    pm.environment.set('createdEpicKey', epic.key);\r",
											"    pm.environment.set('createdEpicSelf', epic.self);\r",
											"    pm.environment.set('epicReady', 'true');\r",
											"    pm.environment.set('epicCreatedAt', new Date().toISOString());\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['updatedProjectKey', 'epicIssueTypeId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"pm.environment.set('epicSummary', `Test Epic ${randomNum}`);\r",
											"pm.environment.set('epicCreateStartTime', Date.now());"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{updatedProjectKey}}\"\r\n        },\r\n        \"summary\": \"{{epicSummary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{epicIssueTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Epic Details",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic loaded successfully', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const epic = pm.response.json();\r",
											"    \r",
											"    pm.expect(epic).to.have.property('id');\r",
											"    pm.expect(epic).to.have.property('key');\r",
											"    pm.expect(epic).to.have.property('fields');\r",
											"    \r",
											"    pm.expect(epic.key).to.eql(pm.environment.get('createdEpicKey'));\r",
											"    \r",
											"    pm.expect(epic.fields.issuetype.name).to.eql('Epic');\r",
											"    pm.expect(epic.fields.issuetype.subtask).to.be.false;\r",
											"    pm.expect(epic.fields.issuetype.hierarchyLevel).to.eql(1);\r",
											"    \r",
											"    pm.expect(epic.fields.project.key).to.eql(pm.environment.get('updatedProjectKey'));\r",
											"    \r",
											"    pm.expect(epic.fields.status.statusCategory.name).to.eql('To Do');\r",
											"    \r",
											"    pm.environment.set('epicPriority', epic.fields.priority.name);\r",
											"    pm.environment.set('epicStatus', epic.fields.status.name);\r",
											"    pm.environment.set('epicStatusId', epic.fields.status.id);\r",
											"    pm.environment.set('epicCurrentSummary', epic.fields.summary);\r",
											"    pm.environment.set('epicType', epic.fields.issuetype.name);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdEpicKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdEpicKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Task",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['updatedProjectKey', 'taskIssueTypeId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"pm.environment.set('taskSummary', `Test Task ${randomNum}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Task created and data saved', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    pm.expect(task).to.have.property('id');\r",
											"    pm.expect(task).to.have.property('key');\r",
											"    pm.expect(task).to.have.property('self');\r",
											"    \r",
											"    pm.expect(task.key).to.include(pm.environment.get('updatedProjectKey'));\r",
											"    \r",
											"    pm.environment.set('createdTaskId', task.id);\r",
											"    pm.environment.set('createdTaskKey', task.key);\r",
											"    pm.environment.set('createdTaskSelf', task.self);\r",
											"    pm.environment.set('taskReady', 'true');\r",
											"    pm.environment.set('taskCreatedAt', new Date().toISOString());\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{updatedProjectKey}}\"\r\n        },\r\n        \"summary\": \"{{taskSummary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{taskIssueTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Task Details",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Task data retrieved and validated', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    \r",
											"    pm.expect(task.key).to.eql(pm.environment.get('createdTaskKey'));\r",
											"    pm.expect(task.id).to.eql(pm.environment.get('createdTaskId'));\r",
											"    pm.expect(task.fields.status.name).to.be.a('string');\r",
											"    \r",
											"    pm.expect(task.fields.issuetype.name).to.eql('Task');\r",
											"    pm.expect(task.fields.issuetype.id).to.eql(pm.environment.get('taskIssueTypeId'));\r",
											"    pm.expect(task.fields.issuetype.subtask).to.be.false;\r",
											"    pm.expect(task.fields.issuetype.hierarchyLevel).to.eql(0);\r",
											"    \r",
											"    pm.expect(task.fields.project.key).to.eql(pm.environment.get('updatedProjectKey'));\r",
											"    pm.expect(task.fields.project.id).to.eql(pm.environment.get('updatedProjectId'));\r",
											"    \r",
											"    pm.expect(task.fields.summary).to.eql(pm.environment.get('taskSummary'));\r",
											"    pm.expect(task.fields.description).to.be.null;\r",
											"    \r",
											"    pm.environment.set('taskStatus', task.fields.status.name);\r",
											"    pm.environment.set('taskStatusId', task.fields.status.id);\r",
											"    pm.environment.set('taskCurrentSummary', task.fields.summary);\r",
											"    pm.environment.set('taskPriority', task.fields.priority.name);\r",
											"    pm.environment.set('taskType', task.fields.issuetype.name);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdTaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdTaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Subtask",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['updatedProjectKey', 'subtaskIssueTypeId', 'createdTaskKey'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"pm.environment.set('subtaskSummary', `Test Subtask ${randomNum}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Subtask created successfully', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const subtask = pm.response.json();\r",
											"    pm.expect(subtask).to.have.property('id');\r",
											"    pm.expect(subtask).to.have.property('key');\r",
											"    pm.expect(subtask).to.have.property('self');\r",
											"    \r",
											"    pm.expect(subtask.key).to.include(pm.environment.get('updatedProjectKey'));\r",
											"    \r",
											"    pm.environment.set('createdSubtaskId', subtask.id);\r",
											"    pm.environment.set('createdSubtaskKey', subtask.key);\r",
											"    pm.environment.set('createdSubtaskSelf', subtask.self);\r",
											"    pm.environment.set('subtaskReady', 'true');\r",
											"    pm.environment.set('subtaskCreatedAt', new Date().toISOString());\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{updatedProjectKey}}\"\r\n        },\r\n        \"summary\": \"{{subtaskSummary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{subtaskIssueTypeId}}\"\r\n        },\r\n        \"parent\": {\r\n            \"key\": \"{{createdTaskKey}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Subtask Details",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Subtask data retrieved and validated', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(3000);\r",
											"    \r",
											"    const subtask = pm.response.json();\r",
											"    \r",
											"    pm.expect(subtask.key).to.eql(pm.environment.get('createdSubtaskKey'));\r",
											"    pm.expect(subtask.id).to.eql(pm.environment.get('createdSubtaskId'));\r",
											"    \r",
											"    pm.expect(subtask.fields.status.statusCategory.name).to.eql('To Do');\r",
											"    \r",
											"    pm.expect(subtask.fields.issuetype.name).to.eql('Subtask');\r",
											"    pm.expect(subtask.fields.issuetype.id).to.eql(pm.environment.get('subtaskIssueTypeId'));\r",
											"    pm.expect(subtask.fields.issuetype.subtask).to.be.true;\r",
											"    pm.expect(subtask.fields.issuetype.hierarchyLevel).to.eql(-1);\r",
											"    \r",
											"    pm.expect(subtask.fields.project.key).to.eql(pm.environment.get('updatedProjectKey'));\r",
											"    pm.expect(subtask.fields.project.id).to.eql(pm.environment.get('updatedProjectId'));\r",
											"    \r",
											"    pm.expect(subtask.fields.summary).to.eql(pm.environment.get('subtaskSummary'));\r",
											"    \r",
											"    pm.expect(subtask.fields).to.have.property('parent');\r",
											"    pm.expect(subtask.fields.parent.key).to.eql(pm.environment.get('createdTaskKey'));\r",
											"    \r",
											"    pm.expect(subtask.fields.description).to.be.null;\r",
											"    \r",
											"    pm.environment.set('subtaskStatus', subtask.fields.status.name);\r",
											"    pm.environment.set('subtaskStatusId', subtask.fields.status.id);\r",
											"    pm.environment.set('subtaskCurrentSummary', subtask.fields.summary);\r",
											"    pm.environment.set('subtaskType', subtask.fields.issuetype.name);\r",
											"    pm.environment.set('subtaskPriority', subtask.fields.priority.name);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdSubtaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdSubtaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Epic",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const exactTimestamp = new Date().toISOString();\r",
											"const randomNum = Math.floor(Math.random() * 1000); \r",
											"const exactText = `Epic updated on ${exactTimestamp}. This Epic now has a description with updated content for testing purposes.`;\r",
											"\r",
											"pm.environment.set('updatedEpicSummary', `Updated Epic ${randomNum} - ${exactTimestamp.slice(0,10)}`);\r",
											"\r",
											"const adfDescription = {\r",
											"    \"type\": \"doc\",\r",
											"    \"version\": 1,\r",
											"    \"content\": [\r",
											"        {\r",
											"            \"type\": \"paragraph\", \r",
											"            \"content\": [\r",
											"                {\r",
											"                    \"type\": \"text\",\r",
											"                    \"text\": exactText\r",
											"                }\r",
											"            ]\r",
											"        }\r",
											"    ]\r",
											"};\r",
											"\r",
											"pm.environment.set('updatedEpicDescriptionADF', JSON.stringify(adfDescription));\r",
											"pm.environment.set('exactEpicText', exactText);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic UPDATE request successful', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);\r",
											"    pm.expect(pm.response.text()).to.be.empty;\r",
											"    \r",
											"    pm.environment.set('epicUpdateCompleted', 'true');\r",
											"    pm.environment.set('epicUpdateTimestamp', new Date().toISOString());\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \"{{updatedEpicSummary}}\",\r\n        \"description\": {{updatedEpicDescriptionADF}}\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdEpicKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdEpicKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Epic after Update",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic update verification - complete validation', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const epic = pm.response.json();\r",
											"    \r",
											"    const expectedSummary = pm.environment.get('updatedEpicSummary');\r",
											"    pm.expect(epic.fields.summary).to.eql(expectedSummary);\r",
											"    \r",
											"    const expectedDescriptionADF = JSON.parse(pm.environment.get('updatedEpicDescriptionADF'));\r",
											"    const actualDescription = epic.fields.description;\r",
											"    \r",
											"    pm.expect(actualDescription.type).to.eql(expectedDescriptionADF.type);\r",
											"    pm.expect(actualDescription.version).to.eql(expectedDescriptionADF.version);\r",
											"    pm.expect(actualDescription.content.length).to.eql(expectedDescriptionADF.content.length);\r",
											"    \r",
											"    const actualTextNode = actualDescription.content[0].content[0];\r",
											"    const expectedTextNode = expectedDescriptionADF.content[0].content[0];\r",
											"    \r",
											"    pm.expect(actualTextNode.type).to.eql(expectedTextNode.type);\r",
											"    pm.expect(actualTextNode.text).to.eql(expectedTextNode.text);\r",
											"    \r",
											"    pm.expect(epic.key).to.eql(pm.environment.get('createdEpicKey'));\r",
											"    pm.expect(epic.id).to.eql(pm.environment.get('createdEpicId'));\r",
											"    \r",
											"    pm.expect(epic.fields.issuetype.name).to.eql('Epic');\r",
											"    pm.expect(epic.fields.issuetype.subtask).to.be.false;\r",
											"    pm.expect(epic.fields.issuetype.hierarchyLevel).to.eql(1);\r",
											"    \r",
											"    pm.expect(epic.fields.project.key).to.eql(pm.environment.get('updatedProjectKey'));\r",
											"    pm.expect(epic.fields.project.id).to.eql(pm.environment.get('updatedProjectId'));\r",
											"    \r",
											"    const expectedAccountId = pm.environment.get('currentUserAccountId');\r",
											"    pm.expect(epic.fields.creator.accountId).to.eql(expectedAccountId);\r",
											"    pm.expect(epic.fields.reporter.accountId).to.eql(expectedAccountId);\r",
											"    pm.expect(epic.fields.assignee).to.be.null;\r",
											"    \r",
											"    pm.expect(epic.fields.labels).to.be.an('array').that.is.empty;\r",
											"    \r",
											"    const updatedTime = new Date(epic.fields.updated);\r",
											"    const now = new Date();\r",
											"    const timeDiffMinutes = (now - updatedTime) / (1000 * 60);\r",
											"    pm.expect(timeDiffMinutes).to.be.below(5);\r",
											"    \r",
											"    pm.environment.set('actualEpicSummary', epic.fields.summary);\r",
											"    pm.environment.set('actualEpicDescription', JSON.stringify(epic.fields.description));\r",
											"    pm.environment.set('actualEpicKey', epic.key);\r",
											"    pm.environment.set('actualEpicType', epic.fields.issuetype.name);\r",
											"    pm.environment.set('actualEpicProject', epic.fields.project.key);\r",
											"    pm.environment.set('actualEpicStatus', epic.fields.status.name);\r",
											"    pm.environment.set('actualEpicUpdated', epic.fields.updated);\r",
											"    pm.environment.set('epicVerified', 'true');\r",
											"    pm.environment.set('epicVerifiedAt', new Date().toISOString());\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdEpicKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdEpicKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Task",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['createdTaskKey', 'taskCurrentSummary'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"const resolvedJobTitle = pm.variables.replaceIn('{{$randomJobTitle}}');\r",
											"pm.environment.set('updatedTaskSummary', `UPDATED Task ${randomNum} - ${resolvedJobTitle}`);\r",
											"\r",
											"const resolvedLoremParagraph = pm.variables.replaceIn('{{$randomLoremParagraph}}');\r",
											"const resolvedTimestamp = pm.variables.replaceIn('{{$timestamp}}');\r",
											"const resolvedFirstName = pm.variables.replaceIn('{{$randomFirstName}}');\r",
											"const resolvedLastName = pm.variables.replaceIn('{{$randomLastName}}');\r",
											"\r",
											"const adfDescription = {\r",
											"    \"type\": \"doc\",\r",
											"    \"version\": 1,\r",
											"    \"content\": [\r",
											"        {\r",
											"            \"type\": \"paragraph\",\r",
											"            \"content\": [\r",
											"                {\r",
											"                    \"type\": \"text\",\r",
											"                    \"text\": `${resolvedLoremParagraph} Updated on ${resolvedTimestamp} by ${resolvedFirstName} ${resolvedLastName}.`\r",
											"                }\r",
											"            ]\r",
											"        }\r",
											"    ]\r",
											"};\r",
											"\r",
											"pm.environment.set('updatedTaskDescriptionADF', JSON.stringify(adfDescription));"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Task updated successfully', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    pm.expect(pm.response.text()).to.be.empty;\r",
											"    \r",
											"    pm.environment.set('taskUpdateSent', 'true');\r",
											"    pm.environment.set('taskUpdateTimestamp', new Date().toISOString());\r",
											"    pm.environment.set('expectedTaskAssignee', pm.environment.get('currentUserAccountId'));\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \"{{updatedTaskSummary}}\",\r\n        \"description\": {{updatedTaskDescriptionADF}},\r\n        \"assignee\": {\"accountId\": \"{{currentUserAccountId}}\"}\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdTaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdTaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Task after Update",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Task update verification - complete validation', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    const expectedSummary = pm.environment.get('updatedTaskSummary');\r",
											"    pm.expect(task.fields.summary).to.eql(expectedSummary);\r",
											"    \r",
											"    const expectedDescriptionADF = JSON.parse(pm.environment.get('updatedTaskDescriptionADF'));\r",
											"    const actualDescription = task.fields.description;\r",
											"    pm.expect(actualDescription.type).to.eql(expectedDescriptionADF.type);\r",
											"    pm.expect(actualDescription.content[0].content[0].text).to.eql(expectedDescriptionADF.content[0].content[0].text);\r",
											"    \r",
											"    const expectedAccountId = pm.environment.get('currentUserAccountId');\r",
											"    pm.expect(task.fields.assignee.accountId).to.eql(expectedAccountId);\r",
											"    \r",
											"    pm.expect(task.key).to.eql(pm.environment.get('createdTaskKey'));\r",
											"    pm.expect(task.fields.issuetype.name).to.eql('Task');\r",
											"    pm.expect(task.fields.project.key).to.eql(pm.environment.get('updatedProjectKey'));\r",
											"    \r",
											"    pm.expect(task.fields.subtasks).to.be.an('array');\r",
											"    pm.expect(task.fields.subtasks.length).to.be.greaterThan(0);\r",
											"    \r",
											"    pm.environment.set('actualTaskSummary', task.fields.summary);\r",
											"    pm.environment.set('actualTaskKey', task.key);\r",
											"    pm.environment.set('taskVerified', 'true');\r",
											"    \r",
											"    console.log(`Task updated with ${task.fields.subtasks.length} subtask(s)`);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdTaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdTaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Subtask",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['createdSubtaskKey', 'subtaskCurrentSummary'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"const resolvedRandomWord = pm.variables.replaceIn('{{$randomWord}}');\r",
											"pm.environment.set('updatedSubtaskSummary', `UPDATED Subtask ${randomNum} - ${resolvedRandomWord}`);\r",
											"\r",
											"const resolvedLoremParagraph = pm.variables.replaceIn('{{$randomLoremParagraph}}');\r",
											"const adfDescription = {\r",
											"    \"type\": \"doc\",\r",
											"    \"version\": 1,\r",
											"    \"content\": [\r",
											"        {\r",
											"            \"type\": \"paragraph\",\r",
											"            \"content\": [\r",
											"                {\r",
											"                    \"type\": \"text\",\r",
											"                    \"text\": resolvedLoremParagraph\r",
											"                }\r",
											"            ]\r",
											"        }\r",
											"    ]\r",
											"};\r",
											"\r",
											"pm.environment.set('updatedSubtaskDescriptionADF', JSON.stringify(adfDescription));"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Subtask updated successfully', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(6000);\r",
											"    pm.expect(pm.response.text()).to.be.empty;\r",
											"    \r",
											"    pm.environment.set('subtaskUpdateCompleted', 'true');\r",
											"    pm.environment.set('subtaskUpdateTimestamp', new Date().toISOString());\r",
											"    pm.environment.set('expectedSubtaskSummary', pm.environment.get('updatedSubtaskSummary'));\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \"{{updatedSubtaskSummary}}\",\r\n        \"description\": {{updatedSubtaskDescriptionADF}},\r\n        \"labels\": [\"updated\", \"testing\"]\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdSubtaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdSubtaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Subtask after Update",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Subtask update verification - complete validation', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const subtask = pm.response.json();\r",
											"    \r",
											"    const expectedSummary = pm.environment.get('updatedSubtaskSummary');\r",
											"    pm.expect(subtask.fields.summary).to.eql(expectedSummary);\r",
											"    \r",
											"    const expectedDescriptionADF = JSON.parse(pm.environment.get('updatedSubtaskDescriptionADF'));\r",
											"    const actualDescription = subtask.fields.description;\r",
											"    pm.expect(actualDescription.content[0].content[0].text).to.eql(expectedDescriptionADF.content[0].content[0].text);\r",
											"    \r",
											"    pm.expect(subtask.fields.labels).to.be.an('array');\r",
											"    pm.expect(subtask.fields.labels).to.have.lengthOf(2);\r",
											"    pm.expect(subtask.fields.labels).to.include('updated');\r",
											"    pm.expect(subtask.fields.labels).to.include('testing');\r",
											"    \r",
											"    pm.expect(subtask.key).to.eql(pm.environment.get('createdSubtaskKey'));\r",
											"    pm.expect(subtask.fields.issuetype.name).to.eql('Subtask');\r",
											"    pm.expect(subtask.fields.parent.key).to.eql(pm.environment.get('createdTaskKey'));\r",
											"    pm.expect(subtask.fields.assignee).to.be.null;\r",
											"    \r",
											"    const updatedTime = new Date(subtask.fields.updated);\r",
											"    const now = new Date();\r",
											"    const timeDiffMinutes = (now - updatedTime) / (1000 * 60);\r",
											"    pm.expect(timeDiffMinutes).to.be.below(10);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdSubtaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdSubtaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete Subtask",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['createdSubtaskKey'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Subtask deleted successfully', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    pm.expect(pm.response.text()).to.be.empty;\r",
											"    \r",
											"    pm.environment.set('subtaskDeleted', 'true');\r",
											"    pm.environment.set('subtaskDeletedAt', new Date().toISOString());\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdSubtaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdSubtaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete Task",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['createdTaskKey'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Task deleted successfully', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(10000);\r",
											"    pm.expect(pm.response.text()).to.be.empty;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdTaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdTaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete Epic",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['createdEpicKey'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic deleted successfully', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    pm.expect(pm.response.text()).to.be.empty;\r",
											"    \r",
											"    pm.environment.set('epicDeleted', 'true');\r",
											"    pm.environment.set('epicDeletedAt', new Date().toISOString());\r",
											"    pm.environment.set('allIssuesDeleted', 'true');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdEpicKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdEpicKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify All Issues Deleted",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Project empty after all issues deleted', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(8000);\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    const issues = response.issues;\r",
											"    \r",
											"    pm.expect(response.total).to.eql(0);\r",
											"    pm.expect(issues).to.be.an('array').that.is.empty;\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/search?jql=project={{updatedProjectKey}}&orderBy=created DESC",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"search"
									],
									"query": [
										{
											"key": "jql",
											"value": "project={{updatedProjectKey}}"
										},
										{
											"key": "orderBy",
											"value": "created DESC"
										}
									]
								}
							},
							"response": []
						}
					]
				}
			],
			"auth": {
				"type": "basic",
				"basic": [
					{
						"key": "password",
						"value": "{{jiraApiToken}}",
						"type": "string"
					},
					{
						"key": "username",
						"value": "{{jiraEmail}}",
						"type": "string"
					}
				]
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Filters",
			"item": [
				{
					"name": "Test Data Generation",
					"item": [
						{
							"name": "Bulk Create Projects",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Loop configuration for creating 3 JQL test projects\r",
											"const maxIterations = 3;\r",
											"let currentIteration = parseInt(pm.environment.get(\"project_creation_iteration\") || \"1\");\r",
											"\r",
											"// Generate unique short ID for this test run\r",
											"let shortId = pm.environment.get(\"jql_short_id\");\r",
											"if (!shortId) {\r",
											"    shortId = Math.floor(Math.random() * 999);\r",
											"    pm.environment.set(\"jql_short_id\", shortId.toString());\r",
											"}\r",
											"\r",
											"console.log(`Creating JQL project ${currentIteration}/${maxIterations}`);\r",
											"\r",
											"const companyName = pm.variables.replaceIn('{{$randomCompanyName}}');\r",
											"const projectNames = ['Alpha', 'Beta', 'Gamma'];\r",
											"\r",
											"// Build project data for current iteration\r",
											"const projectData = {\r",
											"    key: `JQL${currentIteration}${shortId}`,\r",
											"    name: `${companyName} - Project ${projectNames[currentIteration - 1]}`,\r",
											"    description: `Test project ${currentIteration} for JQL testing`,\r",
											"    projectTypeKey: \"software\",\r",
											"    projectTemplateKey: \"com.pyxis.greenhopper.jira:gh-simplified-agility-kanban\",\r",
											"    leadAccountId: pm.environment.get('currentUserAccountId'),\r",
											"    assigneeType: \"UNASSIGNED\"\r",
											"};\r",
											"\r",
											"pm.environment.set('currentJqlProjectKey', projectData.key);\r",
											"pm.environment.set('currentJqlProjectName', projectData.name);\r",
											"pm.environment.set('currentJqlProjectDescription', projectData.description);\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Validate iteration state\r",
											"const maxIterations = 3;\r",
											"let currentIteration = parseInt(pm.environment.get(\"project_creation_iteration\") || \"1\");\r",
											"\r",
											"if (isNaN(currentIteration) || currentIteration < 1) {\r",
											"    currentIteration = 1;\r",
											"    pm.environment.set(\"project_creation_iteration\", \"1\");\r",
											"}\r",
											"\r",
											"pm.test(`JQL Project ${currentIteration}/${maxIterations} - Creation and storage`, function () {\r",
											"    if (!pm.response) {\r",
											"        throw new Error('No response received');\r",
											"    }\r",
											"    \r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(15000);\r",
											"    \r",
											"    const project = pm.response.json();\r",
											"    pm.expect(project).to.have.property('id');\r",
											"    pm.expect(project).to.have.property('key');\r",
											"    pm.expect(project).to.have.property('self');\r",
											"    \r",
											"    const expectedKey = pm.environment.get('currentJqlProjectKey');\r",
											"    pm.expect(project.key).to.eql(expectedKey);\r",
											"    \r",
											"    // Store project data for later use\r",
											"    pm.environment.set(`jqlProject${currentIteration}Key`, project.key);\r",
											"    pm.environment.set(`jqlProject${currentIteration}Id`, project.id);\r",
											"    pm.environment.set(`jqlProject${currentIteration}Self`, project.self);\r",
											"    \r",
											"    console.log(` JQL project ${currentIteration} created and stored: ${project.key} (ID: ${project.id})`);\r",
											"});\r",
											"\r",
											"// Loop control logic\r",
											"const justCompletedIteration = currentIteration;\r",
											"\r",
											"if (justCompletedIteration < maxIterations) {\r",
											"    // Continue to next iteration\r",
											"    const nextIteration = justCompletedIteration + 1;\r",
											"    pm.environment.set(\"project_creation_iteration\", nextIteration.toString());\r",
											"    postman.setNextRequest(pm.info.requestName);\r",
											"} else {\r",
											"    // All iterations completed - cleanup and finalize\r",
											"    console.log(`All ${maxIterations} JQL project iterations completed`);\r",
											"    \r",
											"    pm.environment.set('allJqlProjectsCreated', 'true');\r",
											"    pm.environment.set('totalJqlProjectsCreated', maxIterations);\r",
											"    \r",
											"    console.log(` Projects: ${pm.environment.get('jqlProject1Key')}, ${pm.environment.get('jqlProject2Key')}, ${pm.environment.get('jqlProject3Key')}`);\r",
											"    \r",
											"    // Clean up loop variables\r",
											"    pm.environment.unset(\"project_creation_iteration\");\r",
											"    pm.environment.unset(\"jql_short_id\");\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"{{currentJqlProjectKey}}\",\r\n    \"name\": \"{{currentJqlProjectName}}\",\r\n    \"description\": \"{{currentJqlProjectDescription}}\",\r\n    \"projectTypeKey\": \"software\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"UNASSIGNED\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Issue Types Metadata",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Issue types metadata retrieved and processed', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(8000);  \r",
											"    \r",
											"    const response = pm.response.json(); \r",
											"    pm.expect(response).to.have.property('projects');\r",
											"    pm.expect(response.projects).to.be.an('array');\r",
											"    pm.expect(response.projects.length).to.be.greaterThan(0);\r",
											"    \r",
											"    const projects = response.projects;\r",
											"    let allRequiredTypesFound = true;\r",
											"    \r",
											"    projects.forEach((project, index) => {\r",
											"        \r",
											"        pm.expect(project).to.have.property('issuetypes');\r",
											"        pm.expect(project.issuetypes).to.be.an('array');\r",
											"        pm.expect(project.issuetypes.length).to.be.greaterThan(0);\r",
											"        \r",
											"        let epicTypeId, taskTypeId, subtaskTypeId;\r",
											"        \r",
											"        project.issuetypes.forEach(issueType => {\r",
											"            const typeName = issueType.name.toLowerCase();\r",
											"            \r",
											"            if (typeName === 'epic') {\r",
											"                epicTypeId = issueType.id;\r",
											"                console.log(`  - Epic: ${issueType.id}`);\r",
											"            } else if (typeName === 'task') {\r",
											"                taskTypeId = issueType.id;\r",
											"                console.log(`  - Task: ${issueType.id}`);\r",
											"            } else if (typeName === 'subtask') {\r",
											"                subtaskTypeId = issueType.id;\r",
											"                console.log(`  - Subtask: ${issueType.id}`);\r",
											"            }\r",
											"        });\r",
											"        \r",
											"        const projectNumber = index + 1;\r",
											"        \r",
											"    \r",
											"        pm.environment.set(`jqlProject${projectNumber}EpicTypeId`, epicTypeId);\r",
											"        pm.environment.set(`jqlProject${projectNumber}TaskTypeId`, taskTypeId);\r",
											"        pm.environment.set(`jqlProject${projectNumber}SubtaskTypeId`, subtaskTypeId);\r",
											"        \r",
											"        if (!epicTypeId || !taskTypeId) {\r",
											"            allRequiredTypesFound = false;\r",
											"        }\r",
											"        \r",
											"        console.log(`Issue type IDs stored for project ${projectNumber} (${project.key})`);\r",
											"    });\r",
											"    \r",
											"    pm.expect(allRequiredTypesFound).to.be.true;\r",
											"    \r",
											"    pm.environment.set('issueTypeMappingReady', 'true');\r",
											"    pm.environment.set('issueTypesMappedAt', new Date().toISOString());\r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/createmeta?projectKeys={{jqlProject1Key}},{{jqlProject2Key}},{{jqlProject3Key}}&expand=projects.issuetypes",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"createmeta"
									],
									"query": [
										{
											"key": "projectKeys",
											"value": "{{jqlProject1Key}},{{jqlProject2Key}},{{jqlProject3Key}}"
										},
										{
											"key": "expand",
											"value": "projects.issuetypes"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Bulk Create Epics",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['jqlProject1Key', 'jqlProject2Key', 'jqlProject1EpicTypeId', 'jqlProject2EpicTypeId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"console.log('jqlProject1EpicTypeId:', pm.environment.get('jqlProject1EpicTypeId'));\r",
											"console.log('jqlProject2EpicTypeId:', pm.environment.get('jqlProject2EpicTypeId'));\r",
											"\r",
											"// Iteration management for 4 epic creation cycles\r",
											"const maxIterations = 4;\r",
											"let currentIteration = parseInt(pm.environment.get(\"epic_creation_iteration\") || \"1\");\r",
											"\r",
											"if (currentIteration < 1 || currentIteration > maxIterations) {\r",
											"    currentIteration = 1;\r",
											"    pm.environment.set(\"epic_creation_iteration\", \"1\");\r",
											"}\r",
											"\r",
											"const epicDistribution = [\r",
											"    { project: pm.environment.get('jqlProject1Key'), issueTypeId: pm.environment.get('jqlProject1EpicTypeId'), name: 'Frontend Development Epic' },\r",
											"    { project: pm.environment.get('jqlProject1Key'), issueTypeId: pm.environment.get('jqlProject1EpicTypeId'), name: 'Backend API Epic' },\r",
											"    { project: pm.environment.get('jqlProject2Key'), issueTypeId: pm.environment.get('jqlProject2EpicTypeId'), name: 'Mobile App Epic' },\r",
											"    { project: pm.environment.get('jqlProject2Key'), issueTypeId: pm.environment.get('jqlProject2EpicTypeId'), name: 'Security Enhancement Epic' }\r",
											"];\r",
											"\r",
											"const epicData = epicDistribution[currentIteration - 1];\r",
											"\r",
											"if (!epicData.issueTypeId) {\r",
											"    throw new Error(`Missing issue type ID for iteration ${currentIteration}`);\r",
											"}\r",
											"\r",
											"pm.environment.set('currentEpicProjectKey', epicData.project);\r",
											"pm.environment.set('currentEpicSummary', `${epicData.name} - ${pm.variables.replaceIn('{{$randomCompanyName}}')}`);\r",
											"pm.environment.set('currentEpicIssueTypeId', epicData.issueTypeId);\r",
											"\r",
											"pm.environment.set('currentEpicDescriptionADF', JSON.stringify({\r",
											"    \"type\": \"doc\",\r",
											"    \"version\": 1,\r",
											"    \"content\": [{\r",
											"        \"type\": \"paragraph\",\r",
											"        \"content\": [{\r",
											"            \"type\": \"text\",\r",
											"            \"text\": `Epic description for ${epicData.name}`\r",
											"        }]\r",
											"    }]\r",
											"}));\r",
											"\r",
											"pm.environment.set('currentEpicLabels', JSON.stringify([\"epic\", \"test\"]));\r",
											"\r",
											"// Debug - verify epic data before request\r",
											"console.log('=== EPIC CREATION DEBUG ===');\r",
											"console.log('Current iteration:', currentIteration);\r",
											"console.log('Epic data:', JSON.stringify(epicData, null, 2));\r",
											"console.log('Project key:', epicData.project);\r",
											"console.log('Issue type ID:', epicData.issueTypeId);\r",
											"console.log('Issue type exists:', !!epicData.issueTypeId);\r",
											"\r",
											"// Additional validation\r",
											"if (!epicData.project) {\r",
											"    throw new Error(`Missing project key for iteration ${currentIteration}`);\r",
											"}\r",
											"if (!epicData.issueTypeId) {\r",
											"    throw new Error(`Missing issue type ID for iteration ${currentIteration}`);\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const maxIterations = 4;\r",
											"const currentIteration = parseInt(pm.environment.get(\"epic_creation_iteration\") || \"1\");\r",
											"\r",
											"pm.test(`Epic ${currentIteration}/${maxIterations} - Creation and storage`, function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(10000);\r",
											"    \r",
											"    const epic = pm.response.json();\r",
											"    pm.expect(epic).to.have.property('id');\r",
											"    pm.expect(epic).to.have.property('key');\r",
											"    pm.expect(epic).to.have.property('self');\r",
											"    \r",
											"    pm.environment.set(`testEpic${currentIteration}Key`, epic.key);\r",
											"    pm.environment.set(`testEpic${currentIteration}Id`, epic.id);\r",
											"    pm.environment.set(`testEpic${currentIteration}Self`, epic.self);\r",
											"    \r",
											"    console.log(` Epic ${currentIteration} created and stored: ${epic.key} (ID: ${epic.id})`);\r",
											"});\r",
											"\r",
											"// Loop control logic\r",
											"const justCompletedIteration = currentIteration;\r",
											"\r",
											"if (justCompletedIteration < maxIterations) {\r",
											"    const nextIteration = justCompletedIteration + 1;\r",
											"    pm.environment.set(\"epic_creation_iteration\", nextIteration.toString());\r",
											"    pm.execution.setNextRequest(pm.info.requestName);\r",
											"} else {\r",
											"    console.log(` All ${maxIterations} Epic iterations completed!`);\r",
											"    \r",
											"    pm.environment.set('allTestEpicsCreated', 'true');\r",
											"    pm.environment.set('totalTestEpicsCreated', maxIterations.toString());\r",
											"    pm.environment.unset(\"epic_creation_iteration\");\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{currentEpicProjectKey}}\"\r\n        },\r\n        \"summary\": \"{{currentEpicSummary}}\",\r\n        \"description\": {{currentEpicDescriptionADF}},\r\n        \"issuetype\": {\r\n            \"id\": \"{{currentEpicIssueTypeId}}\"\r\n        },\r\n        \"labels\": {{currentEpicLabels}}\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Bulk Create Tasks",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const maxIterations = 7;\r",
											"let currentIteration = parseInt(pm.environment.get(\"task_creation_iteration\") || \"1\");\r",
											"\r",
											"if (currentIteration < 1 || currentIteration > maxIterations) {\r",
											"   currentIteration = 1;\r",
											"   pm.environment.set(\"task_creation_iteration\", \"1\");\r",
											"}\r",
											"\r",
											"const taskDistribution = [\r",
											"   { assignee: pm.environment.get('currentUserAccountId'), labels: [] },\r",
											"   { assignee: null, labels: [] },\r",
											"   { assignee: null, labels: [] },\r",
											"   { assignee: null, labels: ['urgent'] },\r",
											"   { assignee: null, labels: ['backend'] },\r",
											"   { assignee: null, labels: ['testing'] },\r",
											"   { assignee: null, labels: [] }\r",
											"];\r",
											"\r",
											"const taskData = taskDistribution[currentIteration - 1];\r",
											"const taskSummary = `Task ${currentIteration} - ${pm.variables.replaceIn('{{$randomJobTitle}}')}`;\r",
											"\r",
											"// Build request body dynamically\r",
											"const requestBody = {\r",
											"   \"fields\": {\r",
											"       \"project\": {\r",
											"           \"key\": pm.environment.get('jqlProject1Key')\r",
											"       },\r",
											"       \"summary\": taskSummary,\r",
											"       \"issuetype\": {\r",
											"           \"id\": pm.environment.get('jqlProject1TaskTypeId')\r",
											"       },\r",
											"       \"labels\": taskData.labels\r",
											"   }\r",
											"};\r",
											"\r",
											"// Add assignee only if exists\r",
											"if (taskData.assignee) {\r",
											"   requestBody.fields.assignee = {\"accountId\": taskData.assignee};\r",
											"}\r",
											"\r",
											"pm.request.body.raw = JSON.stringify(requestBody);\r",
											"\r",
											"console.log(`Creating Task ${currentIteration}/${maxIterations}: ${taskSummary}`);\r",
											"console.log('Body:', JSON.stringify(requestBody, null, 2));"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const maxIterations = 7;\r",
											"const currentIteration = parseInt(pm.environment.get(\"task_creation_iteration\") || \"1\");\r",
											"\r",
											"pm.test(`Task ${currentIteration}/${maxIterations} - Creation and storage`, function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    pm.expect(task).to.have.property('key');\r",
											"    pm.expect(task).to.have.property('id');\r",
											"\r",
											"    pm.environment.set(`testTask${currentIteration}Key`, task.key);\r",
											"    pm.environment.set(`testTask${currentIteration}Id`, task.id);\r",
											"    pm.environment.set(`testTask${currentIteration}Summary`, pm.environment.get('currentTaskSummary'));\r",
											"    pm.environment.set(`testTask${currentIteration}Labels`, pm.environment.get('currentTaskLabels'));\r",
											"    pm.environment.set(`testTask${currentIteration}Assignee`, pm.environment.get('currentTaskAssignee'));\r",
											"    \r",
											"    console.log(` Task ${currentIteration} created and stored: ${task.key}`);\r",
											"});\r",
											"\r",
											"// ============ LOOP CONTROL ============\r",
											"if (currentIteration < maxIterations) {\r",
											"    pm.environment.set(\"task_creation_iteration\", (currentIteration + 1).toString());\r",
											"    pm.execution.setNextRequest(pm.info.requestName);\r",
											"} else {\r",
											"    console.log(\" All 7 tasks created for JQL testing!\");\r",
											"    pm.environment.unset(\"task_creation_iteration\");\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Bulk Create Subtasks",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const maxIterations = 4;\r",
											"let currentIteration = parseInt(pm.environment.get(\"subtask_creation_iteration\") || \"1\");\r",
											"\r",
											"if (currentIteration < 1 || currentIteration > maxIterations) {\r",
											"    currentIteration = 1;\r",
											"    pm.environment.set(\"subtask_creation_iteration\", \"1\");\r",
											"}\r",
											"\r",
											"const subtaskDistribution = [\r",
											"    { parentTask: pm.environment.get('testTask1Key'), assignee: pm.environment.get('currentUserAccountId'), name: 'Frontend Implementation' },\r",
											"    { parentTask: pm.environment.get('testTask1Key'), assignee: null, name: 'Code Review' },\r",
											"    { parentTask: pm.environment.get('testTask4Key'), assignee: null, name: 'Security Analysis' },\r",
											"    { parentTask: pm.environment.get('testTask4Key'), assignee: pm.environment.get('currentUserAccountId'), name: 'Vulnerability Testing' }\r",
											"];\r",
											"\r",
											"const subtaskData = subtaskDistribution[currentIteration - 1];\r",
											"const subtaskSummary = `${subtaskData.name} - ${pm.variables.replaceIn('{{$randomJobArea}}')}`;\r",
											"\r",
											"// Build request body dynamically\r",
											"const requestBody = {\r",
											"    \"fields\": {\r",
											"        \"project\": {\r",
											"            \"key\": pm.environment.get('jqlProject1Key')\r",
											"        },\r",
											"        \"summary\": subtaskSummary,\r",
											"        \"issuetype\": {\r",
											"            \"id\": pm.environment.get('jqlProject1SubtaskTypeId')\r",
											"        },\r",
											"        \"parent\": {\r",
											"            \"key\": subtaskData.parentTask\r",
											"        }\r",
											"    }\r",
											"};\r",
											"\r",
											"// Add assignee only if exists\r",
											"if (subtaskData.assignee) {\r",
											"    requestBody.fields.assignee = {\"accountId\": subtaskData.assignee};\r",
											"}\r",
											"\r",
											"pm.request.body.raw = JSON.stringify(requestBody);\r",
											"\r",
											"console.log(`Creating Subtask ${currentIteration}/${maxIterations}: ${subtaskSummary} for ${subtaskData.parentTask}`);\r",
											"console.log('Body:', JSON.stringify(requestBody, null, 2));"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const maxIterations = 4;\r",
											"const currentIteration = parseInt(pm.environment.get(\"subtask_creation_iteration\") || \"1\");\r",
											"\r",
											"pm.test(`Subtask ${currentIteration}/${maxIterations} - Creation and storage`, function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const subtask = pm.response.json();\r",
											"    pm.expect(subtask).to.have.property('key');\r",
											"    pm.expect(subtask).to.have.property('id');\r",
											"    \r",
											"    pm.environment.set(`testSubtask${currentIteration}Key`, subtask.key);\r",
											"    pm.environment.set(`testSubtask${currentIteration}Id`, subtask.id);\r",
											"    \r",
											"    console.log(`Subtask ${currentIteration} created and stored: ${subtask.key}`);\r",
											"});\r",
											"if (currentIteration < maxIterations) {\r",
											"    const nextIteration = currentIteration + 1;\r",
											"    pm.environment.set(\"subtask_creation_iteration\", nextIteration.toString());\r",
											"    pm.execution.setNextRequest(pm.info.requestName);\r",
											"} else {\r",
											"    console.log(`All ${maxIterations} subtasks created for JQL testing!`);\r",
											"    pm.environment.set('allTestSubtasksCreated', 'true');\r",
											"    pm.environment.unset(\"subtask_creation_iteration\");\r",
											"    \r",
											"    console.log('Complete JQL test dataset ready');\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Create Filter 01 - Single Project",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const requiredVars = ['jqlProject1Key', 'jiraBaseUrl'];\r",
									"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
									"\r",
									"if (missingVars.length > 0) {\r",
									"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
									"}\r",
									"\r",
									"const projectKey = pm.environment.get('jqlProject1Key');\r",
									"const filterName = 'Filter Test 01 - Single Project';\r",
									"const filterJql = `project = ${projectKey}`;\r",
									"\r",
									"const filterBody = {\r",
									"    \"name\": filterName,\r",
									"    \"jql\": filterJql\r",
									"};\r",
									"\r",
									"pm.request.body.raw = JSON.stringify(filterBody);\r",
									"pm.environment.set('expectedFilterName', filterName);\r",
									"pm.environment.set('expectedFilterJql', filterJql);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"CREATE Filter 01 - Filter created successfully\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    const expectedName = pm.environment.get('expectedFilterName');\r",
									"    const expectedJql = pm.environment.get('expectedFilterJql');\r",
									"   \r",
									"    pm.expect(response).to.have.property('id');\r",
									"    pm.expect(response).to.have.property('name');\r",
									"    pm.expect(response).to.have.property('jql');\r",
									"    pm.expect(response).to.have.property('viewUrl');\r",
									"    pm.expect(response).to.have.property('searchUrl');\r",
									"    \r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.isWritable).to.eql(true);\r",
									"    pm.expect(response.favourite).to.eql(false);\r",
									"    \r",
									"    pm.environment.set('filterTest01Name', expectedName);\r",
									"    pm.environment.set('filterTest01Id', response.id);\r",
									"    pm.environment.set('filterTest01Data', JSON.stringify({\r",
									"        id: response.id,\r",
									"        name: response.name,\r",
									"        jql: response.jql\r",
									"    }));\r",
									"    \r",
									"    console.log(` Filter created: ${response.name} (ID: ${response.id})`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{jiraBaseUrl}}/filter",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Filter 02 - My Assigned Tasks",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const projectKey = pm.environment.get('jqlProject1Key');\r",
									"if (!projectKey) {\r",
									"    throw new Error('Missing jqlProject1Key - run Test Data Generation first');\r",
									"}\r",
									"\r",
									"const filterName = 'Filter Test 02 - My Assigned Tasks';\r",
									"const filterJql = `assignee = currentUser() AND project = ${projectKey}`;\r",
									"\r",
									"const filterBody = {\r",
									"    \"name\": filterName,\r",
									"    \"jql\": filterJql\r",
									"};\r",
									"\r",
									"pm.request.body.raw = JSON.stringify(filterBody);\r",
									"pm.environment.set('expectedFilterName', filterName);\r",
									"pm.environment.set('expectedFilterJql', filterJql);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"CREATE Filter 02 - Filter created successfully\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    const expectedName = pm.environment.get('expectedFilterName');\r",
									"    const expectedJql = pm.environment.get('expectedFilterJql');\r",
									"    \r",
									"    pm.expect(response).to.have.property('id');\r",
									"    pm.expect(response).to.have.property('viewUrl');\r",
									"    pm.expect(response).to.have.property('searchUrl');\r",
									"    \r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.isWritable).to.eql(true);\r",
									"    pm.expect(response.favourite).to.eql(false);\r",
									"    \r",
									"    pm.environment.set('filterTest02Name', expectedName);\r",
									"    pm.environment.set('filterTest02Id', response.id);\r",
									"    pm.environment.set('filterTest02Data', JSON.stringify({\r",
									"        id: response.id,\r",
									"        name: response.name,\r",
									"        jql: response.jql\r",
									"    }));\r",
									"    \r",
									"    console.log(`Filter created: ${response.name} (ID: ${response.id})`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{jiraBaseUrl}}/filter",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Filter 03 - Multiple Labels",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Parse labels from multiple test tasks to build comprehensive filter\r",
									"function parseLabelsFromTask(taskLabelsVar) {\r",
									"    const labelsString = pm.environment.get(taskLabelsVar);\r",
									"    return labelsString ? JSON.parse(labelsString) : [];\r",
									"}\r",
									"\r",
									"const task4Labels = parseLabelsFromTask('testTask4Labels');\r",
									"const task5Labels = parseLabelsFromTask('testTask5Labels');\r",
									"const task6Labels = parseLabelsFromTask('testTask6Labels');\r",
									"\r",
									"// Combine all labels from different tasks\r",
									"let allLabels = [...task4Labels, ...task5Labels, ...task6Labels];\r",
									"\r",
									"// Use fallback labels if no test data available\r",
									"if (allLabels.length === 0) {\r",
									"    allLabels = [\"urgent\", \"backend\", \"testing\"];\r",
									"    console.log(\"Using fallback labels\");\r",
									"}\r",
									"\r",
									"console.log(`Found labels from test data: ${allLabels.join(', ')}`);\r",
									"\r",
									"const filterName = \"Filter Test 03 - Multiple Labels\";\r",
									"// Build JQL query that matches any of the collected labels\r",
									"const labelsJql = `labels in (\"${allLabels.join('\", \"')})\")`;\r",
									"\r",
									"const filterBody = {\r",
									"    \"name\": filterName,\r",
									"    \"jql\": labelsJql\r",
									"};\r",
									"\r",
									"pm.request.body.raw = JSON.stringify(filterBody);\r",
									"pm.environment.set('expectedFilterName', filterName);\r",
									"pm.environment.set('expectedFilterJql', labelsJql);\r",
									"pm.environment.set('testLabelsUsed', JSON.stringify(allLabels));"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"CREATE Filter 03 - Filter created successfully\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    const expectedName = pm.environment.get('expectedFilterName');\r",
									"    const expectedJql = pm.environment.get('expectedFilterJql');\r",
									"    \r",
									"    pm.expect(response).to.have.property('id');\r",
									"    pm.expect(response).to.have.property('viewUrl');\r",
									"    pm.expect(response).to.have.property('searchUrl');\r",
									"    \r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.isWritable).to.eql(true);\r",
									"    pm.expect(response.favourite).to.eql(false);\r",
									"    \r",
									"    pm.environment.set('filterTest03Name', expectedName);\r",
									"    pm.environment.set('filterTest03Id', response.id);\r",
									"    pm.environment.set('filterTest03Data', JSON.stringify({\r",
									"        id: response.id,\r",
									"        name: response.name,\r",
									"        jql: response.jql\r",
									"    }));\r",
									"    \r",
									"    console.log(`Filter created: ${response.name} (ID: ${response.id})`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{jiraBaseUrl}}/filter",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter"
							]
						}
					},
					"response": []
				},
				{
					"name": "Create Filter 04 - Complex Cross-Project",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Validate both projects exist for cross-project query\r",
									"const project1Key = pm.environment.get('jqlProject1Key');\r",
									"const project2Key = pm.environment.get('jqlProject2Key');\r",
									"\r",
									"if (!project1Key || !project2Key) {\r",
									"    throw new Error('Missing project keys - run Test Data Generation first');\r",
									"}\r",
									"\r",
									"const filterName = 'Filter Test 04 - Complex Cross-Project';\r",
									"// Build complex JQL spanning multiple projects with assignee filter\r",
									"const complexJql = `project in (${project1Key}, ${project2Key}) AND issuetype in (Epic, Task, Sub-task) AND assignee is not EMPTY`;\r",
									"\r",
									"const filterBody = {\r",
									"    \"name\": filterName,\r",
									"    \"jql\": complexJql\r",
									"};\r",
									"\r",
									"pm.request.body.raw = JSON.stringify(filterBody);\r",
									"pm.environment.set('expectedFilterName', filterName);\r",
									"pm.environment.set('expectedFilterJql', complexJql);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"CREATE Filter 04 - Filter created successfully\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    const expectedName = pm.environment.get('expectedFilterName');\r",
									"    const expectedJql = pm.environment.get('expectedFilterJql');\r",
									"    \r",
									"    // Validate essential filter properties\r",
									"    pm.expect(response).to.have.property('id');\r",
									"    pm.expect(response).to.have.property('viewUrl');\r",
									"    pm.expect(response).to.have.property('searchUrl');\r",
									"    \r",
									"    // Verify filter configuration matches complex cross-project request\r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.isWritable).to.eql(true);\r",
									"    pm.expect(response.favourite).to.eql(false);\r",
									"    \r",
									"    // Store filter data for subsequent cross-project tests\r",
									"    pm.environment.set('filterTest04Name', expectedName);\r",
									"    pm.environment.set('filterTest04Id', response.id);\r",
									"    pm.environment.set('filterTest04ExpectedCount', '3');\r",
									"    pm.environment.set('filterTest04Data', JSON.stringify({\r",
									"        id: response.id,\r",
									"        name: response.name,\r",
									"        jql: response.jql\r",
									"    }));\r",
									"    \r",
									"    console.log(`Complex filter created: ${response.name} (ID: ${response.id})`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{jiraBaseUrl}}/filter",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get All Test Filters",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const filterIds = [\r",
									"    pm.environment.get('filterTest01Id'),\r",
									"    pm.environment.get('filterTest02Id'), \r",
									"    pm.environment.get('filterTest03Id'),\r",
									"    pm.environment.get('filterTest04Id')\r",
									"];\r",
									"\r",
									"const validFilterIds = filterIds.filter(id => id && id !== 'undefined');\r",
									"\r",
									"pm.environment.set('expectedFilterCount', validFilterIds.length.toString());\r",
									"pm.environment.set('expectedFilterIds', JSON.stringify(validFilterIds));\r",
									"\r",
									"console.log(`Expecting to find ${validFilterIds.length} test filters`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"GET All Filters - Complete verification\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(6000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    pm.expect(response).to.have.property('values');\r",
									"    pm.expect(response.values).to.be.an('array');\r",
									"    \r",
									"    const expectedNames = [\r",
									"        pm.environment.get('filterTest01Name'),\r",
									"        pm.environment.get('filterTest02Name'),\r",
									"        pm.environment.get('filterTest03Name'),\r",
									"        pm.environment.get('filterTest04Name')\r",
									"    ].filter(name => name);\r",
									"    \r",
									"    const ourFilters = response.values.filter(f => \r",
									"        expectedNames.includes(f.name)\r",
									"    );\r",
									"    \r",
									"    // Verify all expected filters are present\r",
									"    pm.expect(ourFilters.length).to.eql(expectedNames.length, \r",
									"        `Expected ${expectedNames.length} test filters, found ${ourFilters.length}`);\r",
									"    \r",
									"    // Verify each expected filter exists with basic properties\r",
									"    expectedNames.forEach(expectedName => {\r",
									"        const found = response.values.find(f => f.name === expectedName);\r",
									"        pm.expect(found, `Filter \"${expectedName}\" should exist`).to.exist;\r",
									"        \r",
									"        // Validate only properties that exist in search response\r",
									"        pm.expect(found).to.have.property('id');\r",
									"        pm.expect(found).to.have.property('name');\r",
									"    });\r",
									"    \r",
									"    console.log(`Verified ${ourFilters.length} test filters in response`);\r",
									"    \r",
									"    // Debug: log first filter structure to understand response format\r",
									"    if (response.values.length > 0) {\r",
									"        console.log('Sample filter structure:', JSON.stringify(response.values[0], null, 2));\r",
									"    }\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{jiraBaseUrl}}/filter/search?filterName=Filter Test&maxResults=10",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter",
								"search"
							],
							"query": [
								{
									"key": "filterName",
									"value": "Filter Test"
								},
								{
									"key": "maxResults",
									"value": "10"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Filter 01 - Enhance JQL",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Validate filter exists before attempting update\r",
									"const filterId = pm.environment.get('filterTest01Id');\r",
									"const projectKey = pm.environment.get('jqlProject1Key');\r",
									"\r",
									"if (!filterId) {\r",
									"    throw new Error('Missing filterTest01Id - run CREATE operations first');\r",
									"}\r",
									"\r",
									"// Enhanced filter configuration with description and label filtering\r",
									"const updatedName = \"Filter Test 01 - Single Project (Enhanced)\";\r",
									"const updatedJql = `project = ${projectKey} AND labels is not EMPTY`;\r",
									"const updatedDescription = \"Enhanced test filter with description field and label filtering added via UPDATE operation\";\r",
									"\r",
									"const updateBody = {\r",
									"    \"name\": updatedName,\r",
									"    \"description\": updatedDescription,\r",
									"    \"jql\": updatedJql\r",
									"};\r",
									"\r",
									"pm.request.body.raw = JSON.stringify(updateBody);\r",
									"\r",
									"pm.environment.set('expectedUpdatedName', updatedName);\r",
									"pm.environment.set('expectedUpdatedJql', updatedJql);\r",
									"pm.environment.set('expectedUpdatedDescription', updatedDescription);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"UPDATE Filter 01 - Enhancement successful\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    const expectedName = pm.environment.get('expectedUpdatedName');\r",
									"    const expectedJql = pm.environment.get('expectedUpdatedJql');\r",
									"    const expectedDescription = pm.environment.get('expectedUpdatedDescription');\r",
									"\r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.description).to.eql(expectedDescription);\r",
									"    pm.expect(response.isWritable).to.eql(true);\r",
									"    \r",
									"    pm.environment.set('filterTest01Name', response.name);\r",
									"    \r",
									"    console.log(`Filter updated: ${response.name} (ID: ${response.id})`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{jiraBaseUrl}}/filter/{{filterTest01Id}}",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter",
								"{{filterTest01Id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Update Filter 02 - Add Field Restrictions",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Validate required variables for filter update\r",
									"const filterId = pm.environment.get('filterTest02Id');\r",
									"const projectKey = pm.environment.get('jqlProject1Key');\r",
									"const originalName = pm.environment.get('filterTest02Name');\r",
									"\r",
									"if (!filterId || !projectKey || !originalName) {\r",
									"    throw new Error('Missing required variables - run previous filter tests first');\r",
									"}\r",
									"\r",
									"// Build enhanced JQL with status and issue type restrictions\r",
									"const restrictedJql = `assignee = currentUser() AND project = ${projectKey} AND status in (\"To Do\", \"In Progress\") AND issuetype != Sub-task`;\r",
									"const updatedName = `${originalName} (Updated)`;\r",
									"const description = 'Shows only my open assigned tasks, excluding subtasks';\r",
									"\r",
									"const updateBody = {\r",
									"    \"name\": updatedName,\r",
									"    \"jql\": restrictedJql,\r",
									"    \"description\": description\r",
									"};\r",
									"\r",
									"pm.request.body.raw = JSON.stringify(updateBody);\r",
									"\r",
									"pm.environment.set('expectedRestrictedJql02', restrictedJql);\r",
									"pm.environment.set('expectedRestrictedName02', updatedName);\r",
									"pm.environment.set('expectedRestrictedDesc02', description);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Filter 02 - Field restrictions added successfully', function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    const expectedName = pm.environment.get('expectedRestrictedName02');\r",
									"    const expectedJql = pm.environment.get('expectedRestrictedJql02');\r",
									"    const expectedDescription = pm.environment.get('expectedRestrictedDesc02');\r",
									"    \r",
									"    // Verify exact matches with expected values\r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.description).to.eql(expectedDescription);\r",
									"    pm.expect(response.isWritable).to.be.true;\r",
									"    \r",
									"    // Verify specific JQL components are present\r",
									"    pm.expect(response.jql).to.include('status in (\"To Do\", \"In Progress\")');\r",
									"    pm.expect(response.jql).to.include('issuetype != Sub-task');\r",
									"    \r",
									"    pm.environment.set('filterTest02Name', response.name);\r",
									"    \r",
									"    console.log(`Filter updated with restrictions: ${response.name}`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "PUT",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "[]",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{jiraBaseUrl}}/filter/{{filterTest02Id}}",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter",
								"{{filterTest02Id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Filter 01 After Update",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const filterId = pm.environment.get('filterTest01Id');\r",
									"if (!filterId) {\r",
									"    throw new Error('Missing filterTest01Id - run CREATE and UPDATE operations first');\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Get Filter 01 - Complete Verification After Update\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    const expectedId = pm.environment.get('filterTest01Id');\r",
									"    const expectedName = pm.environment.get('expectedUpdatedName');\r",
									"    const expectedJql = pm.environment.get('expectedUpdatedJql');\r",
									"    const expectedDescription = pm.environment.get('expectedUpdatedDescription');\r",
									"    \r",
									"    // Verify filter identity and permissions\r",
									"    pm.expect(response.id).to.eql(expectedId);\r",
									"    pm.expect(response.isWritable).to.eql(true);\r",
									"    \r",
									"    // Verify updated content matches expectations\r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.description).to.eql(expectedDescription);\r",
									"    \r",
									"    // Verify filter URLs are properly formatted\r",
									"    pm.expect(response.viewUrl).to.be.a('string').and.not.be.empty;\r",
									"    pm.expect(response.searchUrl).to.be.a('string').and.not.be.empty;\r",
									"    pm.expect(response.viewUrl).to.include(`filter=${expectedId}`);\r",
									"    \r",
									"    console.log(`Filter verification complete: ${response.name} (ID: ${response.id})`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{jiraBaseUrl}}/filter/{{filterTest01Id}}",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter",
								"{{filterTest01Id}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Filter 02 After Update",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Filter 02 - Complete verification after update', function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    \r",
									"    const response = pm.response.json();\r",
									"    \r",
									"    // Get stored expected values from UPDATE request\r",
									"    const expectedId = pm.environment.get('filterTest02Id');\r",
									"    const expectedName = pm.environment.get('filterTest02Name');\r",
									"    const expectedJql = pm.environment.get('expectedRestrictedJql02');\r",
									"    const expectedDesc = pm.environment.get('expectedRestrictedDesc02');\r",
									"    const expectedAccountId = pm.environment.get('currentUserAccountId');\r",
									"    \r",
									"    // Verify content matches updated values\r",
									"    pm.expect(response.id).to.eql(expectedId);\r",
									"    pm.expect(response.name).to.eql(expectedName);\r",
									"    pm.expect(response.jql).to.eql(expectedJql);\r",
									"    pm.expect(response.description).to.eql(expectedDesc);\r",
									"    \r",
									"    // Verify basic metadata and permissions\r",
									"    pm.expect(response.owner.accountId).to.eql(expectedAccountId);\r",
									"    pm.expect(response.isWritable).to.be.true;\r",
									"    \r",
									"    console.log(`Filter 02 verification complete: ${response.name}`);\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{jiraBaseUrl}}/filter/{{filterTest02Id}}",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter",
								"{{filterTest02Id}}"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Negative Scenarios",
			"item": [
				{
					"name": "Project Creation Errors",
					"item": [
						{
							"name": "Create Project - Invalid Characters",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Invalid characters - Should fail with 400', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"});\r",
											"\r",
											"pm.test('Invalid characters - Error mentions character violation', function () {\r",
											"    const response = pm.response.json();\r",
											"    const errorText = JSON.stringify(response).toLowerCase();\r",
											"    \r",
											"    const hasCharError = errorText.includes('invalid') || \r",
											"                        errorText.includes('illegal') ||\r",
											"                        errorText.includes('character') ||\r",
											"                        errorText.includes('allowed') ||\r",
											"                        errorText.includes('forbidden') ||\r",
											"                        errorText.includes('special');\r",
											"    \r",
											"    pm.expect(hasCharError).to.be.true;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"INV@LID\",\r\n    \"name\": \"Project with @#$ invalid chars\",\r\n    \"projectTypeKey\": \"software\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Project with Existing Key",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Duplicate key - Should fail with 400', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errorMessages || response.errors).to.exist;\r",
											"});\r",
											"\r",
											"pm.test('Duplicate key - Error message validation', function () {\r",
											"    const response = pm.response.json();\r",
											"    \r",
											"    // Check both errorMessages array and errors object\r",
											"    let errorText = '';\r",
											"    \r",
											"    if (response.errorMessages && response.errorMessages.length > 0) {\r",
											"        errorText = response.errorMessages.join(' ').toLowerCase();\r",
											"    }\r",
											"    \r",
											"    if (response.errors) {\r",
											"        errorText += ' ' + JSON.stringify(response.errors).toLowerCase();\r",
											"    }\r",
											"    \r",
											"    const hasKeyError = errorText.includes('key') && \r",
											"                       (errorText.includes('uses') || \r",
											"                        errorText.includes('exist') || \r",
											"                        errorText.includes('duplicate') ||\r",
											"                        errorText.includes('already'));\r",
											"    \r",
											"    pm.expect(hasKeyError).to.be.true;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const existingKey = pm.environment.get('updatedProjectKey');\r",
											"\r",
											"if (!existingKey) {\r",
											"    throw new Error('No updated project found. Run UPDATE project request first.');\r",
											"}\r",
											"\r",
											"pm.environment.set('duplicateProjectKey', existingKey);\r",
											"pm.environment.set('duplicateProjectName', 'Duplicate Key Test Project');\r",
											"pm.environment.set('duplicateProjectDescription', 'This should fail because key already exists');\r",
											"pm.environment.set('duplicateRequestStartTime', Date.now());"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n   \"key\": \"{{updatedProjectKey}}\",\r\n    \"name\": \"Duplicate Key Test Project\",\r\n    \"description\": \"This should fail because key already exists\",\r\n    \"projectTypeKey\": \"{{projectType}}\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"PROJECT_LEAD\",\r\n    \"avatarId\": \"{{projectAvatarId}}\"\r\n}\r\n",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Project with Numeric Only Key",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const numericKey = '123456789';\r",
											"\r",
											"pm.environment.set('numericProjectKey', numericKey);\r",
											"pm.environment.set('numericProjectName', `Numeric Key Project ${numericKey}`);\r",
											"pm.environment.set('numericProjectDescription', `Edge case test: project with numeric-only key ${numericKey} - Created: ${new Date().toISOString()}`);\r",
											"\r",
											"const requiredVars = ['jiraBaseUrl', 'currentUserAccountId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"console.log(`Creating project with numeric-only key: ${numericKey}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Numeric-only key rejected - validation rule enforced', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errorMessages).to.be.an('array').that.is.empty;\r",
											"    pm.expect(response.errors).to.have.property('projectKey');\r",
											"    \r",
											"    const projectKeyError = response.errors.projectKey;\r",
											"    pm.expect(projectKeyError).to.include('Project keys must start with an uppercase letter');\r",
											"    pm.expect(projectKeyError).to.include('uppercase alphanumeric characters');\r",
											"    \r",
											"    console.log('JIRA business rule: Project keys cannot be purely numeric');\r",
											"    console.log(`Error: ${projectKeyError}`);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"{{numericProjectKey}}\",\r\n    \"name\": \"{{numericProjectName}}\",\r\n    \"description\": \"{{numericProjectDescription}}\",\r\n    \"projectTypeKey\": \"software\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"PROJECT_LEAD\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Project with Long Key",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Long key - Should fail with 400', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"});\r",
											"\r",
											"pm.test('Long key - Error mentions length limit', function () {\r",
											"    const response = pm.response.json();\r",
											"    const errorText = JSON.stringify(response).toLowerCase();\r",
											"    \r",
											"    const hasLengthError = errorText.includes('length') || \r",
											"                          errorText.includes('long') ||\r",
											"                          errorText.includes('maximum') ||\r",
											"                          errorText.includes('limit') ||\r",
											"                          errorText.includes('exceed');\r",
											"    \r",
											"    pm.expect(hasLengthError).to.be.true;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"LONGPROJECTKEY123{{$randomBankAccountIban}}\",\r\n    \"name\": \"Project with too long key\",\r\n    \"projectTypeKey\": \"software\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Reuse Deleted Project Key",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const deletedProjectKey = pm.environment.get('projectToDeleteKey');\r",
											"\r",
											"if (!deletedProjectKey) {\r",
											"    throw new Error('No deleted project key found - run Basic CRUD tests first');\r",
											"}\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Reused deleted project key rejected', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errors).to.have.property('projectKey');\r",
											"    pm.expect(response.errors.projectKey).to.include('uses this project key');\r",
											"    \r",
											"    console.log('JIRA business rule: Cannot immediately reuse deleted project keys');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"{{projectToDeleteKey}}\",\r\n    \"name\": \"Reused Deleted Project Key Test\",\r\n    \"description\": \"Edge case test: attempting to reuse a previously deleted project key\",\r\n    \"projectTypeKey\": \"software\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"PROJECT_LEAD\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Project - Existing Name",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const jqlProjectKey = pm.environment.get('jqlProject1Key');\r",
											"const existingProjectName = pm.environment.get('updatedProjectName');\r",
											"\r",
											"if (!jqlProjectKey) {\r",
											"    throw new Error('No JQL project found - run Test Data Generation first');\r",
											"}\r",
											"\r",
											"if (!existingProjectName) {\r",
											"    throw new Error('No existing project name found - run Basic CRUD tests first');\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Update JQL project to existing name rejected', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errors).to.have.property('projectName');\r",
											"    \r",
											"    const nameError = response.errors.projectName.toLowerCase();\r",
											"    const validErrors = [\r",
											"        'a project with that name already exists',\r",
											"        'project name already exists',\r",
											"        'name already taken',\r",
											"        'duplicate project name',\r",
											"        'name is not available'\r",
											"    ];\r",
											"    \r",
											"    const hasValidError = validErrors.some(error => nameError.includes(error));\r",
											"    pm.expect(hasValidError).to.be.true;\r",
											"    \r",
											"    console.log('JIRA business rule: Project names must be unique');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"{{updatedProjectName}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project/{{jqlProject1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project",
										"{{jqlProject1Key}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Issue Creation Errors",
					"item": [
						{
							"name": "Create Epic without Summary",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Create Epic without summary - validation error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    \r",
											"    // Verify error structure and summary field validation\r",
											"    pm.expect(response.errors).to.exist;\r",
											"    pm.expect(response.errors.summary).to.exist;\r",
											"    \r",
											"    const summaryError = response.errors.summary.toLowerCase();\r",
											"    const hasSummaryError = summaryError.includes('summary') && \r",
											"                           (summaryError.includes('specify') || \r",
											"                            summaryError.includes('required') ||\r",
											"                            summaryError.includes('must'));\r",
											"    \r",
											"    pm.expect(hasSummaryError).to.be.true;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{updatedProjectKey}}\"\r\n        },\r\n        \"issuetype\": {\r\n            \"id\": \"{{epicIssueTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Task - Invalid Project",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Invalid project - Should fail with 400', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"});\r",
											"\r",
											"pm.test('Invalid project - Error confirms project required', function () {\r",
											"    const response = pm.response.json();\r",
											"    \r",
											"    pm.expect(response.errors).to.exist;\r",
											"    pm.expect(response.errors.project).to.exist;\r",
											"    \r",
											"    const projectError = response.errors.project.toLowerCase();\r",
											"    const hasProjectError = projectError.includes('project') && \r",
											"                           (projectError.includes('required') || \r",
											"                            projectError.includes('valid') ||\r",
											"                            projectError.includes('not found'));\r",
											"    \r",
											"    pm.expect(hasProjectError).to.be.true;\r",
											"    console.log(' Error confirms invalid project reference');\r",
											"    console.log('Project error:', response.errors.project);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"NONEXISTENT\"\r\n        },\r\n        \"summary\": \"Test issue with invalid project\",\r\n        \"issuetype\": {\r\n            \"name\": \"Task\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Task - Invalid Feb 29 Non-Leap Year",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['jqlProject1Key', 'jqlProject1TaskTypeId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"pm.environment.set('invalidFeb29Summary', `Invalid Feb 29 Future Task ${randomNum}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Invalid Feb 29 date validation - non-leap year rejected', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    \r",
											"    // Verify date validation error for Feb 29 in non-leap year 2027\r",
											"    pm.expect(response.errors).to.have.property('duedate');\r",
											"    pm.expect(response.errors.duedate).to.include('format \"yyyy-MM-dd\"');\r",
											"    pm.expect(response.errorMessages).to.be.an('array').that.is.empty;\r",
											"    pm.expect(response.errors.duedate).to.be.a('string');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{jqlProject1Key}}\"\r\n        },\r\n        \"summary\": \"{{invalidFeb29Summary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1TaskTypeId}}\"\r\n        },\r\n        \"duedate\": \"2027-02-29\"\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Task in Deleted Project",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Create issue in deleted project returns correct error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    \r",
											"    pm.expect(response.errors).to.have.property('project');\r",
											"    pm.expect(response.errors.project.toLowerCase()).to.include('project');\r",
											"    pm.expect(response.errors.project.toLowerCase()).to.include('required');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{projectToDeleteKey}}\"\r\n        },\r\n        \"summary\": \"Test issue in deleted project\",\r\n        \"issuetype\": {\r\n            \"name\": \"Task\"\r\n        }\r\n    }\r\n}\r\n",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Subtask with Epic as Parent",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['jqlProject1Key', 'jqlProject1SubtaskTypeId', 'testEpic1Key'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"const jobArea = pm.variables.replaceIn('{{$randomJobArea}}');\r",
											"\r",
											"pm.environment.set('subtaskWithEpicSummary', `Direct Epic Subtask ${randomNum} - ${jobArea}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Direct Epic-Subtask hierarchy rejected by Jira', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errors).to.have.property('parentId');\r",
											"    pm.expect(response.errors.parentId).to.include('appropriate hierarchy');\r",
											"});\r",
											"\r",
											"pm.test('Hierarchy validation error message', function () {\r",
											"    const response = pm.response.json();\r",
											"    const errorMsg = response.errors.parentId.toLowerCase();\r",
											"    \r",
											"    pm.expect(errorMsg).to.include('hierarchy');\r",
											"    pm.expect(errorMsg).to.include('parent');\r",
											"    pm.expect(errorMsg).to.include('appropriate');\r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{jqlProject1Key}}\"\r\n        },\r\n        \"summary\": \" {{subtaskWithEpicSummary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1SubtaskTypeId}}\"\r\n        },\r\n        \"parent\": {\r\n            \"key\": \"{{testEpic1Key}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Subtask with Deleted Parent",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Create subtask with deleted parent fails with parent error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errors).to.have.property('parent');\r",
											"    pm.expect(response.errors.parent).to.include('Could not find');\r",
											"    pm.expect(response.errors.parent).to.include('issue');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{updatedProjectKey}}\"\r\n        },\r\n        \"summary\": \"Subtask with deleted parent\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{subtaskIssueTypeId}}\"\r\n        },\r\n        \"parent\": {\r\n            \"key\": \"{{createdEpicKey}}\"\r\n        }\r\n    }\r\n}\r\n",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Issue Update Errors",
					"item": [
						{
							"name": "Update Epic Empty Summary",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Update epic with empty summary returns validation error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errors).to.have.property('summary');\r",
											"    pm.expect(response.errors.summary).to.include('must specify a summary');\r",
											"    pm.expect(response.errorMessages).to.be.an('array').that.is.empty;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \" \",\r\n        \"description\": {{updatedEpicDescriptionADF}}\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testEpic1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testEpic1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Deleted Epic",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Update deleted epic returns not found error', function () {\r",
											"    pm.response.to.have.status(404);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errorMessages).to.be.an('array');\r",
											"    pm.expect(response.errorMessages[0]).to.include('Issue does not exist');\r",
											"    pm.expect(response.errors).to.be.an('object').that.is.empty;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \"Trying to update deleted epic\"\r\n    }\r\n}\r\n",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdEpicKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdEpicKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Task - Invalid User Assignment",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Invalid user assignment - Should fail with 400', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"});\r",
											"\r",
											"pm.test('Invalid user assignment - Error confirms user issue', function () {\r",
											"    const response = pm.response.json();\r",
											"    \r",
											"    pm.expect(response.errors).to.exist;\r",
											"    pm.expect(response.errors.assignee).to.exist;\r",
											"    \r",
											"    const assigneeError = response.errors.assignee.toLowerCase();\r",
											"    const hasAssigneeError = assigneeError.includes('assignee') && \r",
											"                            (assigneeError.includes('valid') || \r",
											"                             assigneeError.includes('specify') ||\r",
											"                             assigneeError.includes('invalid') ||\r",
											"                             assigneeError.includes('not found'));\r",
											"    \r",
											"    pm.expect(hasAssigneeError).to.be.true;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \"Task with invalid user assignment\",\r\n        \"assignee\": {\"accountId\": \"invalid-user-123456\"}\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Task - Wrong Content Type Error",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Update with wrong content type returns unsupported media error', function () {\r",
											"    pm.response.to.have.status(415);\r",
											"    \r",
											"    const responseText = pm.response.text();\r",
											"    if (responseText) {\r",
											"        pm.expect(responseText.toLowerCase()).to.include('media type');\r",
											"    }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": "text/plain",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "This is plain text instead of JSON",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Task Invalid Label",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Update task with invalid labels returns validation error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errors).to.have.property('labels');\r",
											"    pm.expect(response.errors.labels).to.include(\"can't contain spaces\");\r",
											"    pm.expect(response.errorMessages).to.be.an('array').that.is.empty;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"labels\": [\"invalid label with spaces\"]\r\n    }\r\n}\r\n",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Subtask - Circular Dependency Self Parent",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const subtaskKey = pm.environment.get('testSubtask1Key');\r",
											"if (!subtaskKey) {\r",
											"    throw new Error('Missing testSubtask1Key for circular dependency test');\r",
											"}\r",
											"\r",
											"pm.environment.set('circularTestSubtask', subtaskKey);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Circular dependency prevention - subtask self parent', function () {\r",
											"    pm.expect([400, 404]).to.include(pm.response.code);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    if (pm.response.code === 400) {\r",
											"        const response = pm.response.json();\r",
											"        \r",
											"        // Verify error indicates circular dependency or hierarchy violation\r",
											"        const errorText = JSON.stringify(response).toLowerCase();\r",
											"        const hasCircularError = errorText.includes('circular') || \r",
											"                                errorText.includes('parent') || \r",
											"                                errorText.includes('hierarchy') ||\r",
											"                                errorText.includes('itself') ||\r",
											"                                errorText.includes('invalid');\r",
											"        \r",
											"        pm.expect(hasCircularError).to.be.true;\r",
											"        \r",
											"    } else if (pm.response.code === 404) {\r",
											"        pm.expect(pm.response.code).to.eql(404);\r",
											"    }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"parent\": {\r\n            \"key\": \"{{testSubtask1Key}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testSubtask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testSubtask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Subtask with too Long Summary",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const longSummary = \"Very long summary text that exceeds maximum allowed length \".repeat(50);\r",
											"pm.environment.set('veryLongSummary', longSummary);\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Update subtask with too long summary returns length error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errors).to.have.property('summary');\r",
											"    pm.expect(response.errors.summary).to.include(\"can't exceed 255 characters\");\r",
											"    pm.expect(response.errorMessages).to.be.an('array').that.is.empty;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \"{{veryLongSummary}}\"\r\n    }\r\n}\r\n",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testSubtask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testSubtask1Key}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Issue Delete Errors",
					"item": [
						{
							"name": "Delete Task Invalid Endpoint",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Delete with invalid endpoint returns not found error', function () {\r",
											"    pm.response.to.have.status(404);\r",
											"    \r",
											"    const responseText = pm.response.text();\r",
											"    \r",
											"    if (responseText.includes('<!doctype html>') || responseText.includes('<html')) {\r",
											"        pm.expect(responseText.toLowerCase()).to.satisfy(text => \r",
											"            text.includes('404') || \r",
											"            text.includes('not found') || \r",
											"            text.includes('page not found') ||\r",
											"            text.includes('resource not found')\r",
											"        );\r",
											"        console.log('Received HTML 404 page instead of JSON');\r",
											"    } else {\r",
											"        \r",
											"        pm.expect(responseText.toLowerCase()).to.include('not found');\r",
											"    }\r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issues/{{testSubtask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issues",
										"{{testSubtask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete Task Multiple Times",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Delete already deleted issue returns not found error', function () {\r",
											"    pm.response.to.have.status(404);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errorMessages).to.be.an('array');\r",
											"    pm.expect(response.errorMessages[0]).to.include('Issue does not exist');\r",
											"    pm.expect(response.errors).to.be.an('object').that.is.empty;\r",
											"    \r",
											"    console.log('Second DELETE correctly returns 404 - issue already deleted');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdTaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdTaskKey}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Access & Security Errors",
					"item": [
						{
							"name": "Get Deleted Epic - Not Found Error",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Get deleted epic returns not found error', function () {\r",
											"    pm.response.to.have.status(404);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errorMessages).to.be.an('array');\r",
											"    pm.expect(response.errorMessages[0]).to.include('Issue does not exist');\r",
											"    pm.expect(response.errors).to.be.an('object').that.is.empty;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{createdEpicKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{createdEpicKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Get Task - Unauthorized Access Error",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Get unauthorized issue returns access denied error', function () {\r",
											"    pm.response.to.have.status(404);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errorMessages).to.be.an('array');\r",
											"    pm.expect(response.errorMessages[0]).to.include('Issue does not exist or you do not have permission');\r",
											"    pm.expect(response.errors).to.be.an('object').that.is.empty;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "noauth"
								},
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Search with Malformed JQL Query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Malformed JQL query returns syntax error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    \r",
											"    // Verify JQL syntax error structure\r",
											"    pm.expect(response.errorMessages).to.be.an('array');\r",
											"    pm.expect(response.errorMessages.length).to.be.greaterThan(0);\r",
											"    pm.expect(response.errors).to.be.an('object').that.is.empty;\r",
											"    \r",
											"    // Verify error mentions JQL parsing issue\r",
											"    const errorText = response.errorMessages[0].toLowerCase();\r",
											"    const hasJqlError = errorText.includes('jql') || \r",
											"                       errorText.includes('query') || \r",
											"                       errorText.includes('syntax');\r",
											"    \r",
											"    pm.expect(hasJqlError).to.be.true;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/search?jql=summary~\"{{actualEpicSummary}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"search"
									],
									"query": [
										{
											"key": "jql",
											"value": "summary~\"{{actualEpicSummary}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get with Body - Invalid Request",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Get request with body blocked by security layer', function () {\r",
											"    pm.response.to.have.status(403);\r",
											"    \r",
											"    const responseText = pm.response.text();\r",
											"    pm.expect(responseText).to.include('403 ERROR');\r",
											"    pm.expect(responseText).to.include('The request could not be satisfied');\r",
											"    pm.expect(responseText).to.include('Bad request');\r",
											"});\r",
											"\r",
											"pm.test('CloudFront security validation', function () {\r",
											"    const responseText = pm.response.text();\r",
											"    pm.expect(responseText).to.include('CloudFront');\r",
											"    pm.expect(responseText).to.include('Generated by cloudfront');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"method": "GET",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"summary\": \"This body should be ignored\",\r\n        \"description\": \"GET requests should not have body\"\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Filter with Invalid JQL",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Invalid JQL - Should fail with 400', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"});\r",
											"\r",
											"pm.test('Invalid JQL - Error confirms syntax issue', function () {\r",
											"    const response = pm.response.json();\r",
											"    const errorText = JSON.stringify(response).toLowerCase();\r",
											"    \r",
											"    const hasJqlError = (errorText.includes('jql') || errorText.includes('query')) && \r",
											"                       (errorText.includes('invalid') || \r",
											"                        errorText.includes('syntax') ||\r",
											"                        errorText.includes('parse') ||\r",
											"                        errorText.includes('malformed') ||\r",
											"                        errorText.includes('error'));\r",
											"    \r",
											"    pm.expect(hasJqlError).to.be.true;\r",
											"    console.log(' Error confirms JQL syntax violation');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"Invalid JQL Test Filter\",\r\n    \"jql\": \"project = {{jqlProject1Key}} AND labels = AND assignee\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/filter",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"filter"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Edge Cases",
			"item": [
				{
					"name": "Project",
					"item": [
						{
							"name": "Create Project with Emoji in Name",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const timestamp = Date.now();\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"\r",
											"pm.environment.set('emojiProjectKey', `EMJ${randomNum}`);\r",
											"pm.environment.set('emojiProjectName', ` Test Project ${randomNum} `);\r",
											"pm.environment.set('emojiProjectDescription', `Automated test project with emojis  Created: ${new Date().toISOString()} `);\r",
											"\r",
											"const requiredVars = ['jiraBaseUrl', 'currentUserAccountId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"console.log(`Creating project with emoji: ${pm.environment.get('emojiProjectName')}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Emoji project created successfully', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const project = pm.response.json();\r",
											"    \r",
											"    pm.expect(project).to.have.property('id');\r",
											"    pm.expect(project).to.have.property('key'); \r",
											"    pm.expect(project.key).to.eql(pm.environment.get('emojiProjectKey'));\r",
											"    \r",
											"    pm.environment.set('emojiProjectId', project.id);\r",
											"    pm.environment.set('emojiProjectKey', project.key);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"key\": \"{{emojiProjectKey}}\",\r\n    \"name\": \"{{emojiProjectName}}\",\r\n    \"description\": \"{{emojiProjectDescription}}\",\r\n    \"projectTypeKey\": \"software\",\r\n    \"projectTemplateKey\": \"{{defaultProjectTemplate}}\",\r\n    \"leadAccountId\": \"{{currentUserAccountId}}\",\r\n    \"assigneeType\": \"PROJECT_LEAD\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Project Name to Match Key",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const emojiProjectKey = pm.environment.get('emojiProjectKey');\r",
											"\r",
											"if (!emojiProjectKey) {\r",
											"    throw new Error('No emoji project found - run Edge Cases emoji project creation first');\r",
											"}\r",
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Project name updated to match key successfully', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const project = pm.response.json();\r",
											"    const expectedKey = pm.environment.get('emojiProjectKey');\r",
											"    \r",
											"    pm.expect(project.name).to.eql(expectedKey);\r",
											"    pm.expect(project.key).to.eql(expectedKey);\r",
											"    pm.expect(project.name).to.eql(project.key);\r",
											"    \r",
											"    console.log(`Edge case validated: Project name and key are identical: ${expectedKey}`);\r",
											"    console.log('System accepts identical name and key without issues');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"name\": \"{{emojiProjectKey}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/project/{{emojiProjectKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"project",
										"{{emojiProjectKey}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Character Sets & Encoding",
					"item": [
						{
							"name": "Create Task with International Characters - Language Support Test",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const unicodeSets = [\r",
											"    {\r",
											"        name: 'Cyrillic',\r",
											"        text: '     ',\r",
											"        prefix: 'CYR'\r",
											"    },\r",
											"    {\r",
											"        name: 'Chinese',\r",
											"        text: '',\r",
											"        prefix: 'CHN'\r",
											"    },\r",
											"    {\r",
											"        name: 'Arabic', \r",
											"        text: '  ',\r",
											"        prefix: 'ARA'\r",
											"    },\r",
											"    {\r",
											"        name: 'Polish',\r",
											"        text: 'Zadanie testowe z polskimi znakami ',\r",
											"        prefix: 'POL'\r",
											"    },\r",
											"    {\r",
											"        name: 'German',\r",
											"        text: 'Testaufgabe mit deutschen Umlauten ',\r",
											"        prefix: 'GER'\r",
											"    }\r",
											"];\r",
											"\r",
											"const maxIterations = unicodeSets.length;\r",
											"let currentIteration = parseInt(pm.environment.get('unicode_iteration') || '1');\r",
											"\r",
											"console.log(`=== PREREQUEST DEBUG ===`);\r",
											"console.log(`Current iteration: ${currentIteration}`);\r",
											"console.log(`Max iterations: ${maxIterations}`);\r",
											"console.log(`Array index will be: ${currentIteration - 1}`);\r",
											"\r",
											"if (currentIteration < 1 || currentIteration > maxIterations) {\r",
											"    currentIteration = 1;\r",
											"    pm.environment.set('unicode_iteration', '1');\r",
											"}\r",
											"\r",
											"const currentSet = unicodeSets[currentIteration - 1];\r",
											"console.log(`Selected set: ${JSON.stringify(currentSet)}`);\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"\r",
											"pm.environment.set('unicodeSummary', `${currentSet.text} ${randomNum}`);\r",
											"pm.environment.set('currentUnicodeType', currentSet.name);\r",
											"pm.environment.set('currentUnicodePrefix', currentSet.prefix);\r",
											"\r",
											"console.log(`Set summary to: ${currentSet.text} ${randomNum}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const maxIterations = 5;\r",
											"const currentIteration = parseInt(pm.environment.get(\"unicode_iteration\") || \"1\");\r",
											"\r",
											"pm.test(`Unicode ${currentIteration}/${maxIterations} - ${pm.environment.get('currentUnicodeType')} task created`, function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    const unicodeType = pm.environment.get('currentUnicodeType');\r",
											"    const fullSummary = pm.environment.get('unicodeSummary'); \r",
											"\r",
											"    pm.expect(task).to.have.property('key');\r",
											"    pm.expect(task).to.have.property('id');\r",
											"    \r",
											"    pm.environment.set(`${unicodeType.toLowerCase()}TaskId`, task.id);\r",
											"    pm.environment.set(`${unicodeType.toLowerCase()}TaskKey`, task.key);\r",
											"    pm.environment.set(`${unicodeType.toLowerCase()}TaskSummary`, fullSummary);\r",
											"    \r",
											"    console.log(`${unicodeType} task created: ${task.key}`);\r",
											"});\r",
											"\r",
											"if (currentIteration < maxIterations) {\r",
											"    pm.environment.set(\"unicode_iteration\", (currentIteration + 1).toString());\r",
											"    postman.setNextRequest(pm.info.requestName);\r",
											"} else {\r",
											"    console.log(\"All Unicode character sets tested!\");\r",
											"    pm.environment.unset(\"unicode_iteration\");\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{jqlProject1Key}}\"\r\n        },\r\n        \"summary\": \"{{unicodeSummary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1TaskTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify Task with International Characters - Language Support Test",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const maxIterations = 5;\r",
											"let currentIteration = parseInt(pm.environment.get('unicode_verify_iteration') || '1');\r",
											"\r",
											"if (currentIteration < 1 || currentIteration > maxIterations) {\r",
											"    currentIteration = 1;\r",
											"    pm.environment.set('unicode_verify_iteration', '1');\r",
											"}\r",
											"\r",
											"const unicodeTypes = ['cyrillic', 'chinese', 'arabic', 'polish', 'german'];\r",
											"const currentType = unicodeTypes[currentIteration - 1];\r",
											"\r",
											"const taskKey = pm.environment.get(`${currentType}TaskKey`);\r",
											"const expectedSummary = pm.environment.get(`${currentType}TaskSummary`);\r",
											"\r",
											"if (!taskKey || !expectedSummary) {\r",
											"    throw new Error(`Missing ${currentType} data - run Unicode creation tests first`);\r",
											"}\r",
											"\r",
											"pm.environment.set('currentUnicodeTaskKey', taskKey);\r",
											"pm.environment.set('expectedUnicodeSummary', expectedSummary);\r",
											"pm.environment.set('currentVerifyType', currentType);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"const maxIterations = 5;\r",
											"let currentIteration = parseInt(pm.environment.get('unicode_verify_iteration'));\r",
											"\r",
											"if (isNaN(currentIteration) || currentIteration < 1) {\r",
											"    currentIteration = 1;\r",
											"}\r",
											"\r",
											"pm.test(`Unicode verification ${currentIteration}/${maxIterations} - ${pm.environment.get('currentVerifyType')} preserved exactly`, function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    const taskKey = pm.environment.get('currentUnicodeTaskKey');\r",
											"    const expectedSummary = pm.environment.get('expectedUnicodeSummary');\r",
											"    \r",
											"    pm.expect(task.key).to.eql(taskKey);\r",
											"    pm.expect(task.fields.summary).to.eql(expectedSummary);\r",
											"    \r",
											"});\r",
											"\r",
											"// Loop control\r",
											"if (currentIteration < maxIterations) {\r",
											"    pm.environment.set('unicode_verify_iteration', (currentIteration + 1).toString());\r",
											"    pm.execution.setNextRequest(pm.info.requestName);\r",
											"} else {\r",
											"    pm.environment.unset('unicode_verify_iteration');\r",
											"    pm.environment.unset('currentVerifyType');\r",
											"    pm.environment.unset('currentUnicodeTaskKey');\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{currentUnicodeTaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{currentUnicodeTaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Issue with Special Characters",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Special characters accepted in summary', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    \r",
											"    pm.expect(task).to.have.property('id');\r",
											"    pm.expect(task).to.have.property('key');\r",
											"    pm.expect(task).to.have.property('self');\r",
											"    \r",
											"    pm.environment.set('specialCharsTaskId', task.id);\r",
											"    pm.environment.set('specialCharsTaskKey', task.key);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{jqlProject1Key}}\"\r\n        },\r\n        \"summary\": \"@#$%^&*()_+-=[]{}|\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1TaskTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								},
								"description": "## Create Issue in JIRA\n\nThis endpoint allows you to create a new issue in a specified JIRA project. By sending a POST request to `{{jiraBaseUrl}}/issue`, you can define the details of the issue you want to create, including the project key, summary, and issue type.\n\n### Request Body Format\n\nThe request body must be in JSON format and should contain the following structure:\n\n``` json\n{\n  \"fields\": {\n    \"project\": {\n      \"key\": \"{{jqlProject1Key}}\"\n    },\n    \"summary\": \"string\",\n    \"issuetype\": {\n      \"id\": \"{{jqlProject1TaskTypeId}}\"\n    }\n  }\n}\n\n ```\n\n#### Parameters:\n\n- **fields**: An object that contains the details of the issue.\n    \n    - **project**: An object specifying the project in which the issue will be created.\n        \n        - **key**: A string representing the project key.\n            \n    - **summary**: A string that provides a brief description of the issue.\n        \n    - **issuetype**: An object that defines the type of issue being created.\n        \n        - **id**: A string representing the ID of the issue type.\n            \n\n### Response Structure\n\nUpon successful creation of the issue, the API will respond with a `201 Created` status code and a JSON object that includes the following fields:\n\n``` json\n{\n  \"id\": \"string\",\n  \"key\": \"string\",\n  \"self\": \"string\"\n}\n\n ```\n\n#### Response Fields:\n\n- **id**: The unique identifier for the newly created issue.\n    \n- **key**: The key of the newly created issue, which is often used to reference it.\n    \n- **self**: A URL that points to the newly created issue resource.\n    \n\n### Status Codes\n\n- **201 Created**: Indicates that the issue has been successfully created.\n    \n- Other potential status codes may be returned based on the request's validity and server response, but are not detailed here.\n    \n\nThis endpoint is essential for automating issue creation in JIRA, allowing for streamlined project management and tracking."
							},
							"response": []
						}
					]
				},
				{
					"name": "Data Limits & Boundaries",
					"item": [
						{
							"name": "Create Issue with Far Future Due Date",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const requiredVars = ['jqlProject1Key', 'jqlProject1TaskTypeId'];\r",
											"const missingVars = requiredVars.filter(varName => !pm.environment.get(varName));\r",
											"\r",
											"if (missingVars.length > 0) {\r",
											"    throw new Error(`Missing required variables: ${missingVars.join(', ')}`);\r",
											"}\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"pm.environment.set('futureDateSummary', `Year 2048 Task ${randomNum}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Testing extreme future date handling (2048-12-31)\r",
											"// Expected: accept as-is OR return validation error\r",
											"// Note: Silent data modification would be a bug\r",
											"\r",
											"pm.test('Far future date handling - accept or reject properly', function () {\r",
											"    if (pm.response.code === 201) {\r",
											"        pm.response.to.be.json;\r",
											"        const task = pm.response.json();\r",
											"        pm.expect(task).to.have.property('id');\r",
											"        pm.expect(task).to.have.property('key');\r",
											"        \r",
											"        pm.environment.set('futureDateTaskId', task.id);\r",
											"        pm.environment.set('futureDateTaskKey', task.key);\r",
											"        \r",
											"    } else if (pm.response.code >= 400 && pm.response.code < 500) {\r",
											"        pm.response.to.be.json;\r",
											"        const response = pm.response.json();\r",
											"        \r",
											"        pm.expect(response).to.have.property('errors');\r",
											"        pm.expect(response.errors).to.have.property('duedate');\r",
											"        \r",
											"        pm.environment.set('futureDateRejected', 'true');\r",
											"        \r",
											"    } else {\r",
											"        pm.expect.fail(`Unexpected response code: ${pm.response.code}`);\r",
											"    }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{jqlProject1Key}}\"\r\n        },\r\n        \"summary\": \"Task with far future due date - {{futureDateSummary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1TaskTypeId}}\"\r\n        },\r\n        \"duedate\": \"2048-12-31\"\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify Far Future Due Date Task",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Far future date verification - detect silent modification', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    const actualDate = task.fields.duedate;\r",
											"    const requestedDate = '2048-12-31';\r",
											"    \r",
											"    pm.expect(actualDate).to.exist;\r",
											"    pm.expect(actualDate).to.match(/\\d{4}-\\d{2}-\\d{2}/);\r",
											"    \r",
											"    console.log(`Requested: ${requestedDate}, API returned: ${actualDate}`);\r",
											"    \r",
											"    if (actualDate !== requestedDate) {\r",
											"        console.log(`BUG: API silently modified date ${requestedDate}  ${actualDate}`);\r",
											"        console.log('Expected: validation error OR preserve original date');\r",
											"        \r",
											"         pm.expect.fail('API should not silently modify user data');\r",
											"    } else {\r",
											"        console.log('API correctly preserved original date');\r",
											"    }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const taskKey = pm.environment.get('futureDateTaskKey');\r",
											"if (!taskKey) {\r",
											"    console.log('No future date task found - skipping verification');\r",
											"    pm.execution.setNextRequest(null);\r",
											"    return;\r",
											"}\r",
											"\r",
											"pm.environment.set('originalRequestedDate', '2048-12-31');"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{futureDateTaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{futureDateTaskKey}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Task - 32766 Character Description Boundary Test",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const taskTypeId = pm.environment.get('jqlProject1TaskTypeId');\r",
											"const epicKey = pm.environment.get('testEpic2Key');\r",
											"\r",
											"if (!taskTypeId) {\r",
											"    throw new Error('Missing taskTypeId for task creation');\r",
											"}\r",
											"\r",
											"if (!epicKey) {\r",
											"    throw new Error('Missing Epic2 key - run Bulk Create Epics first');\r",
											"}\r",
											"\r",
											"const largeText = \"x\".repeat(32766);\r",
											"const largeADF = {\r",
											"    \"type\": \"doc\",\r",
											"    \"version\": 1,\r",
											"    \"content\": [{\r",
											"        \"type\": \"paragraph\",\r",
											"        \"content\": [{\r",
											"            \"type\": \"text\",\r",
											"            \"text\": largeText\r",
											"        }]\r",
											"    }]\r",
											"};\r",
											"\r",
											"const randomNum = Math.floor(Math.random() * 1000);\r",
											"pm.environment.set('largeTaskSummary', `Large Task ${randomNum} under Epic`);\r",
											"pm.environment.set('largeDescriptionADF', JSON.stringify(largeADF));\r",
											"\r",
											"console.log(`Creating large task under Epic: ${epicKey}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Jira description limit: 32767 chars (API documentation)\r",
											"// 3-point boundary analysis: testing 32766 (below limit)\r",
											"\r",
											"pm.test('Description size boundary - 32,766 characters accepted', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"     pm.expect(pm.response.responseTime).to.be.below(7000);\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    pm.expect(task).to.have.property('key');\r",
											"    pm.expect(task).to.have.property('id');\r",
											"    \r",
											"    const textSize = 32766;\r",
											"    const totalJsonSize = JSON.stringify(JSON.parse(pm.environment.get('largeDescriptionADF'))).length;\r",
											"    \r",
											"    pm.expect(textSize).to.eql(32766);\r",
											"    pm.environment.set('maxDescTaskKey', task.key);\r",
											"    \r",
											"\r",
											"    pm.expect(pm.response.responseTime).to.be.below(80000);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{jqlProject1Key}}\"\r\n        },\r\n        \"summary\": \"{{largeTaskSummary}}\",\r\n        \"description\": {{largeDescriptionADF}},\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1TaskTypeId}}\"\r\n        },\r\n        \"parent\": {\r\n            \"key\": \"{{testEpic2Key}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Create Subtask - 255 Character Summary Boundary Test",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Jira summary limit: 255 chars (API documentation)\r",
											"// Boundary analysis: testing 255 (at limit)\r",
											"const parentTaskKey = pm.environment.get('maxDescTaskKey'); // Should be JQL1864-21\r",
											"const subtaskTypeId = pm.environment.get('jqlProject1SubtaskTypeId');\r",
											"\r",
											"console.log(`Parent task key: ${parentTaskKey}`);\r",
											"\r",
											"if (!parentTaskKey || !subtaskTypeId) {\r",
											"    throw new Error('Missing variables - run max description task creation first');\r",
											"}\r",
											"\r",
											"const baseText = \"Subtask boundary test for maximum summary length validation in Jira API automation testing with precise character counting \";\r",
											"const padding = \"x\".repeat(255 - baseText.length);\r",
											"const maxSummary = baseText + padding;\r",
											"\r",
											"if (maxSummary.length !== 255) {\r",
											"    throw new Error(`Summary length is ${maxSummary.length}, expected 255`);\r",
											"}\r",
											"\r",
											"pm.environment.set('maxSubtaskSummary', maxSummary);\r",
											"pm.environment.set('subtaskParentKey', parentTaskKey);\r",
											"\r",
											"console.log(`Creating subtask under: ${parentTaskKey}`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Jira summary limit: 255 chars (API documentation)\r",
											"// Boundary analysis: testing 255 (at limit)\r",
											"\r",
											"pm.test('Subtask with 255 chars created successfully', function () {\r",
											"    pm.response.to.have.status(201);\r",
											"    \r",
											"    const subtask = pm.response.json();\r",
											"    pm.expect(subtask).to.have.property('key');\r",
											"    pm.expect(subtask).to.have.property('id');\r",
											"    \r",
											"    const summaryLength = pm.environment.get('maxSubtaskSummary').length;\r",
											"    pm.expect(summaryLength).to.eql(255);\r",
											"    \r",
											"    pm.environment.set('maxSummarySubtaskKey', subtask.key);\r",
											"    pm.environment.set('epicHasTaskWithSubtask', 'true');\r",
											"    pm.environment.set('hierarchyForDeletionTest', 'ready');\r",
											"    \r",
											"    console.log(`Subtask created: ${subtask.key} under Task ${pm.environment.get('subtaskParentKey')}`);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"project\": {\r\n            \"key\": \"{{jqlProject1Key}}\"\r\n        },\r\n        \"summary\": \"{{maxSubtaskSummary}}\",\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1SubtaskTypeId}}\"\r\n        },\r\n        \"parent\": {\r\n            \"key\": \"{{subtaskParentKey}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify 255 Character Summary Preserved",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('255 character summary preserved exactly', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    const expectedSummary = pm.environment.get('maxSubtaskSummary'); \r",
											"    \r",
											"    pm.expect(task.fields.summary).to.eql(expectedSummary);\r",
											"    pm.expect(task.fields.summary.length).to.eql(255);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{maxSummarySubtaskKey}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{maxSummarySubtaskKey}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Labels & Metadata Testing",
					"item": [
						{
							"name": "Update Task - 1000 Labels",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"// Jira labels: no documented limit (testing system behavior)\r",
											"\r",
											"pm.test('1000 labels API limit test', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(10000);\r",
											"    \r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const thousandLabels = Array(1000).fill().map((_, i) => `label${i}`);\r",
											"\r",
											"pm.environment.set('thousandLabelsArray', JSON.stringify(thousandLabels));\r",
											"console.log(`Testing ${thousandLabels.length} labels on clean task`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"labels\": {{thousandLabelsArray}}\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify 1000 Labels Count on Task",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('1000 labels verification - API limit discovery', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    const actualLabels = task.fields.labels || [];\r",
											"    const expectedCount = 1000;\r",
											"    \r",
											"    pm.expect(actualLabels).to.be.an('array');\r",
											"    \r",
											"    // API limit discovery analysis\r",
											"    console.log(`Label limit test: Expected ${expectedCount}, Got ${actualLabels.length}`);\r",
											"    \r",
											"    if (actualLabels.length === 1000) {\r",
											"        console.log('RESULT: No API limit at 1000 labels');\r",
											"    } else if (actualLabels.length === 0) {\r",
											"        console.log('RESULT: All labels rejected - possible payload/processing limit');\r",
											"    } else {\r",
											"        console.log(`RESULT: API limit discovered at ${actualLabels.length} labels`);\r",
											"    }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Labels - Case Variations Test",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const caseVariationLabels = [\r",
											"    \"Test\",\r",
											"    \"test\", \r",
											"    \"TEST\",\r",
											"    \"Backend\",\r",
											"    \"backend\",\r",
											"    \"BACKEND\",\r",
											"    \"Api\",\r",
											"    \"api\",\r",
											"    \"API\"\r",
											"];\r",
											"\r",
											"pm.environment.set('caseLabelsArray', JSON.stringify(caseVariationLabels));\r",
											"console.log(`Testing ${caseVariationLabels.length} labels with case variations`);\r",
											"console.log('Labels:', caseVariationLabels);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Case variation labels update', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(3000);\r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"labels\": {{caseLabelsArray}}\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask5Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask5Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify Labels Case Sensitivity - Distinct vs Duplicate Behavior",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Labels case sensitivity - all 9 variations preserved as distinct', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    \r",
											"    const task = pm.response.json();\r",
											"    const actualLabels = task.fields.labels || [];\r",
											"\r",
											"    pm.expect(actualLabels).to.have.lengthOf(9);\r",
											"    pm.expect(actualLabels).to.include.members([\r",
											"        'Test', 'test', 'TEST',\r",
											"        'Backend', 'backend', 'BACKEND',  \r",
											"        'Api', 'api', 'API'\r",
											"    ]);\r",
											"    \r",
											"    console.log('RESULT: Jira API is case-sensitive for labels');\r",
											"    console.log(`Labels: ${actualLabels.join(', ')}`);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask5Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask5Key}}"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Issue Type Conversions",
					"item": [
						{
							"name": "Delete Task with Subtasks",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Delete task with subtasks returns parameter required error', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    pm.expect(response.errorMessages).to.be.an('array');\r",
											"    pm.expect(response.errorMessages[0]).to.include('has subtasks');\r",
											"    pm.expect(response.errorMessages[0]).to.include('deleteSubtasks');\r",
											"    pm.expect(response.errors).to.be.an('object').that.is.empty;\r",
											"    \r",
											"    console.log('JIRA business rule: Cannot delete parent without deleteSubtasks parameter');\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Content-Type",
										"value": "text/plain",
										"type": "text",
										"disabled": true
									}
								],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Issue Type - Epic to Task Without Children",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const epicKey = pm.environment.get('testEpic1Key');\r",
											"const taskTypeId = pm.environment.get('jqlProject1TaskTypeId');\r",
											"\r",
											"if (!epicKey || !taskTypeId) {\r",
											"    throw new Error('Missing required variables for issue type change test');\r",
											"}\r",
											"\r",
											"console.log(`Changing ${epicKey} from Epic to Task`);\r",
											"console.log(`Task type ID: ${taskTypeId}`);\r",
											"\r",
											"pm.environment.set('originalIssueType', 'Epic');\r",
											"pm.environment.set('targetIssueType', 'Task');\r",
											"pm.environment.set('targetTaskTypeId', taskTypeId);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic without children successfully converts to Task', function () {\r",
											"    pm.response.to.have.status(204);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(3000);\r",
											"\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"issuetype\": {\r\n            \"id\": \"{{targetTaskTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testEpic1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testEpic1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify Epic to Task Conversion - No Children Case",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic to Task conversion verified - hierarchy downgrade successful', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    \r",
											"    const issue = pm.response.json();\r",
											"    \r",
											"    pm.expect(issue.fields.issuetype.name).to.eql('Task');\r",
											"    pm.expect(issue.fields.issuetype.hierarchyLevel).to.eql(0);\r",
											"    pm.expect(issue.fields.issuetype.subtask).to.be.false;\r",
											"    pm.expect(issue.fields.subtasks).to.be.an('array').that.is.empty;\r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testEpic1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testEpic1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Update Issue Type - Epic to Subtask Hierarchy Test",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const epicKey = pm.environment.get('testEpic1Key');\r",
											"const subtaskTypeId = pm.environment.get('jqlProject1SubtaskTypeId');\r",
											"\r",
											"if (!epicKey || !subtaskTypeId) {\r",
											"    throw new Error('Missing required variables for Epic to Subtask test');\r",
											"}\r",
											"\r",
											"console.log(`Testing Epic to Subtask conversion: ${epicKey}`);\r",
											"console.log(`Subtask type ID: ${subtaskTypeId}`);\r",
											"\r",
											"pm.environment.set('originalEpicType', 'Epic');\r",
											"pm.environment.set('targetSubtaskType', 'Subtask');"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic to Subtask conversion blocked by hierarchy rules', function () {\r",
											"    pm.response.to.have.status(400);\r",
											"    pm.response.to.be.json;\r",
											"    \r",
											"    const response = pm.response.json();\r",
											"    const errorText = JSON.stringify(response).toLowerCase();\r",
											"    \r",
											"    const hasHierarchyError = errorText.includes('hierarchy') || \r",
											"                             errorText.includes('parent') ||\r",
											"                             errorText.includes('subtask') ||\r",
											"                             errorText.includes('inappropriate');\r",
											"    \r",
											"    pm.expect(hasHierarchyError).to.be.true;\r",
											"    \r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1SubtaskTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testEpic1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testEpic1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Convert Task with Subtasks to Epic",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const taskKey = pm.environment.get('testTask1Key');\r",
											"const epicTypeId = pm.environment.get('jqlProject1EpicTypeId');\r",
											"\r",
											"if (!taskKey) {\r",
											"    throw new Error('No task with subtasks found - run Bulk Create Tests first');\r",
											"}\r",
											"\r",
											"if (!epicTypeId) {\r",
											"    throw new Error('No Epic type ID found - run Test Data Generation first');\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Task with subtasks conversion to Epic - business rule validation', function () {\r",
											"    pm.expect([400, 204]).to.include(pm.response.code);\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    if (pm.response.code === 400) {\r",
											"        pm.response.to.be.json;\r",
											"        console.log('API blocked conversion - consistent with DELETE business rules');\r",
											"        \r",
											"    } else if (pm.response.code === 204) {\r",
											"        // API inconsistency: DELETE with subtasks fails, but UPDATE succeeds\r",
											"        console.log('CRITICAL: TaskEpic conversion succeeded despite having subtasks');\r",
											"        console.log('This creates orphaned subtasks and API inconsistency with DELETE operations');\r",
											"        \r",
											"        pm.environment.set('taskToEpicConversionSucceeded', 'true');\r",
											"    }\r",
											"    \r",
											"    // Note: Good API design should maintain consistent business rules across operations\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"fields\": {\r\n        \"issuetype\": {\r\n            \"id\": \"{{jqlProject1EpicTypeId}}\"\r\n        }\r\n    }\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Verify Task to Epic Conversion",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Task to Epic conversion verification', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const issue = pm.response.json();\r",
											"    \r",
											"    // Verify hierarchy change\r",
											"    pm.expect(issue.fields.issuetype.name).to.eql('Epic');\r",
											"    pm.expect(issue.fields.issuetype.hierarchyLevel).to.eql(1);\r",
											"    pm.expect(issue.fields.issuetype.subtask).to.be.false;\r",
											"    \r",
											"    // Check subtasks relationship integrity\r",
											"    pm.expect(issue.fields.subtasks).to.be.an('array');\r",
											"    \r",
											"    if (issue.fields.subtasks.length === 0) {\r",
											"        console.log('CRITICAL: Subtasks orphaned after conversion - data integrity violation');\r",
											"        pm.environment.set('subtasksOrphaned', 'true');\r",
											"    } else {\r",
											"        pm.environment.set('subtasksOrphaned', 'false');\r",
											"    }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const taskKey = pm.environment.get('testTask1Key');\r",
											"const conversionSucceeded = pm.environment.get('taskToEpicConversionSucceeded');\r",
											"\r",
											"if (!taskKey) {\r",
											"    throw new Error('No task found for verification');\r",
											"}\r",
											"\r",
											"if (conversionSucceeded !== 'true') {\r",
											"    pm.execution.setNextRequest(null);\r",
											"    return;\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testTask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testTask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Check Subtask After Parent Epic Conversion",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Subtask integrity after parent Epic conversion', function () {\r",
											"    pm.response.to.have.status(200);\r",
											"    pm.response.to.be.json;\r",
											"    pm.expect(pm.response.responseTime).to.be.below(5000);\r",
											"    \r",
											"    const subtask = pm.response.json();\r",
											"    \r",
											"    // Scenario 1: Subtask converted to Task (acceptable)\r",
											"    if (subtask.fields.issuetype.name === 'Task') {\r",
											"        console.log('Subtask automatically converted to Task - hierarchy maintained');\r",
											"        pm.environment.set('subtaskConvertedToTask', 'true');\r",
											"        return;\r",
											"    }\r",
											"    \r",
											"    // Scenario 2: Still Subtask - must have parent reference\r",
											"    pm.expect(subtask.fields.issuetype.name).to.eql('Subtask');\r",
											"    \r",
											"    if (!subtask.fields.parent) {\r",
											"        console.log('CRITICAL: Orphaned subtask detected - data integrity violation');\r",
											"        pm.expect.fail('Subtask exists without parent reference - violates hierarchical data model');\r",
											"    }\r",
											"    \r",
											"    console.log(`Subtask relationship maintained with parent: ${subtask.fields.parent.key}`);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"// Validate test dependencies - this test requires successful parent conversion\r",
											"const taskKey = pm.environment.get('testTask1Key');\r",
											"const conversionSucceeded = pm.environment.get('taskToEpicConversionSucceeded');\r",
											"const subtaskKey = pm.environment.get('testSubtask1Key');\r",
											"\r",
											"if (!taskKey || !subtaskKey) {\r",
											"    console.log('Missing required task/subtask keys - skipping test');\r",
											"    pm.execution.setNextRequest(null);\r",
											"    return;\r",
											"}\r",
											"\r",
											"if (conversionSucceeded !== 'true') {\r",
											"    console.log('Previous Epic conversion test failed - skipping subtask verification');\r",
											"    pm.execution.setNextRequest(null);\r",
											"    return;\r",
											"}"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testSubtask1Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testSubtask1Key}}"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete Epic with Task-Subtask Hierarchy",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											"const epicKey = pm.environment.get('testEpic2Key');\r",
											"const hierarchyReady = pm.environment.get('hierarchyForDeletionTest');\r",
											"\r",
											"if (!epicKey) {\r",
											"    throw new Error('No Epic found for deletion test');\r",
											"}\r",
											"\r",
											"if (hierarchyReady !== 'ready') {\r",
											"    throw new Error('Epic hierarchy not ready - run Task and Subtask creation first');\r",
											"}\r",
											"\r",
											"console.log(`Testing Epic deletion: ${epicKey} with TaskSubtask hierarchy`);"
										],
										"type": "text/javascript",
										"packages": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Epic deletion with nested Task-Subtask hierarchy', function () {\r",
											"    if (pm.response.code === 204) {\r",
											"        // Epic deleted successfully despite having nested hierarchy\r",
											"        console.log('Epic with TaskSubtask hierarchy deleted successfully');\r",
											"        console.log('System allowed deletion of Epic with complex nested relationships');\r",
											"        \r",
											"        pm.environment.set('epicDeletedWithHierarchy', 'true');\r",
											"        \r",
											"    } else if (pm.response.code === 400) {\r",
											"        // Deletion blocked due to hierarchy relationships\r",
											"        pm.response.to.be.json;\r",
											"        const response = pm.response.json();\r",
											"        \r",
											"        console.log('Epic deletion blocked - hierarchy protection active');\r",
											"        console.log(`Error: ${JSON.stringify(response.errorMessages || response.errors)}`);\r",
											"        \r",
											"        const errorText = JSON.stringify(response).toLowerCase();\r",
											"        const hasHierarchyError = errorText.includes('task') || \r",
											"                                 errorText.includes('subtask') ||\r",
											"                                 errorText.includes('children') ||\r",
											"                                 errorText.includes('hierarchy');\r",
											"        \r",
											"        pm.expect(hasHierarchyError).to.be.true;\r",
											"        \r",
											"    } else {\r",
											"        pm.expect.fail(`Unexpected response code: ${pm.response.code}`);\r",
											"    }\r",
											"});\r",
											"\r",
											"pm.test('Business rule consistency across hierarchy levels', function () {\r",
											"    // This test validates whether JIRA applies consistent deletion rules\r",
											"    // across different hierarchy levels (Epic vs Task vs Subtask)\r",
											"    console.log('Testing deletion rule consistency: Epic with hierarchy vs Task with subtasks');\r",
											"    \r",
											"    if (pm.response.code === 204) {\r",
											"        console.log('INCONSISTENCY: Epic deletion allowed despite nested relationships');\r",
											"    } else {\r",
											"        console.log('CONSISTENCY: Epic deletion blocked like Task deletion was');\r",
											"    }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{jiraBaseUrl}}/issue/{{testEpic2Key}}",
									"host": [
										"{{jiraBaseUrl}}"
									],
									"path": [
										"issue",
										"{{testEpic2Key}}"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Cleanup",
			"item": [
				{
					"name": "Delete All Test Filters",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"console.log(\"=== DELETE Test Filters Loop ===\");\r",
									"if (!pm.environment.get(\"delete_iteration\")) {\r",
									"    pm.environment.set(\"delete_iteration\", \"1\");\r",
									"}\r",
									"\r",
									"const maxIterations = 4;\r",
									"const currentIteration = parseInt(pm.environment.get(\"delete_iteration\"));\r",
									"\r",
									"// Reset logic if out of bounds\r",
									"if (currentIteration < 1 || currentIteration > maxIterations) {\r",
									"    pm.environment.set(\"delete_iteration\", \"1\");\r",
									"    currentIteration = 1;\r",
									"}\r",
									"const filterIds = [\r",
									"    pm.environment.get('filterTest01Id'),\r",
									"    pm.environment.get('filterTest02Id'), \r",
									"    pm.environment.get('filterTest03Id'),\r",
									"    pm.environment.get('filterTest04Id')\r",
									"];\r",
									"\r",
									"const filterNames = [\r",
									"    pm.environment.get('filterTest01Name'),\r",
									"    pm.environment.get('filterTest02Name'),\r",
									"    pm.environment.get('filterTest03Name'), \r",
									"    pm.environment.get('filterTest04Name')\r",
									"];\r",
									"\r",
									"const currentFilterId = filterIds[currentIteration - 1];\r",
									"const currentFilterName = filterNames[currentIteration - 1];\r",
									"\r",
									"if (!currentFilterId) {\r",
									"    throw new Error(`Missing filter ID for iteration ${currentIteration}`);\r",
									"}\r",
									"pm.environment.set('currentFilterIdToDelete', currentFilterId);\r",
									"pm.environment.set('currentFilterNameToDelete', currentFilterName);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const maxIterations = 4;\r",
									"const currentIteration = parseInt(pm.environment.get(\"delete_iteration\"));\r",
									"// Loop control\r",
									"if (currentIteration < maxIterations) {\r",
									"    const nextIteration = currentIteration + 1;\r",
									"    pm.environment.set(\"delete_iteration\", nextIteration.toString());\r",
									"    console.log(`Completed deletion ${currentIteration}. Next: ${nextIteration}`);\r",
									"    pm.execution.setNextRequest(pm.info.requestName);\r",
									"} else {\r",
									"    pm.test('All test filters deletion completed', function () {\r",
									"        pm.response.to.have.status(204);\r",
									"        pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    });\r",
									"    \r",
									"    console.log(`All ${maxIterations} test filters deleted!`);\r",
									"    \r",
									"    // Final cleanup\r",
									"    pm.environment.unset(\"delete_iteration\");\r",
									"    pm.environment.unset(\"currentFilterIdToDelete\");\r",
									"    pm.environment.unset(\"currentFilterNameToDelete\");\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{jiraBaseUrl}}/filter/{{currentFilterIdToDelete}}",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"filter",
								"{{currentFilterIdToDelete}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Get All Test Projects",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Identify test projects for cleanup', function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    pm.response.to.be.json;\r",
									"    pm.expect(pm.response.responseTime).to.be.below(10000);\r",
									"    \r",
									"    const projects = pm.response.json();\r",
									"    pm.expect(projects).to.be.an('array');\r",
									"    \r",
									"    // Identify test projects by common patterns\r",
									"    const testProjectPatterns = /^(TEST|JQL|DEL|NEGATIVE|EMJ|CYR|CHN|ARA|POL|GER)/i;\r",
									"    const testProjects = projects.filter(project => \r",
									"        testProjectPatterns.test(project.key) || \r",
									"        project.name.toLowerCase().includes('test')\r",
									"    );\r",
									"    \r",
									"    // Store all test projects for deletion\r",
									"    const projectsForDeletion = testProjects.map(project => ({\r",
									"        id: project.id,\r",
									"        key: project.key,\r",
									"        name: project.name\r",
									"    }));\r",
									"    \r",
									"    pm.environment.set('allProjectsForDeletion', JSON.stringify(projectsForDeletion));\r",
									"    pm.environment.set('totalProjectsCount', projectsForDeletion.length);\r",
									"    \r",
									"    console.log(`Found ${projectsForDeletion.length} test projects for cleanup:`);\r",
									"    projectsForDeletion.forEach(project => {\r",
									"        console.log(`- ${project.key}: ${project.name}`);\r",
									"    });\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{jiraBaseUrl}}/project",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"project"
							]
						}
					},
					"response": []
				},
				{
					"name": "Delete All Test Projects",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const projectsToDelete = [\r",
									"    pm.environment.get('updatedProjectKey'),\r",
									"    pm.environment.get('jqlProject1Key'),\r",
									"    pm.environment.get('jqlProject2Key'),\r",
									"    pm.environment.get('jqlProject3Key'),\r",
									"    pm.environment.get('emojiProjectKey')\r",
									"].filter(key => key && key !== 'undefined');\r",
									"\r",
									"const maxIterations = projectsToDelete.length;\r",
									"let currentIteration = parseInt(pm.environment.get('delete_iteration') || '1');\r",
									"\r",
									"if (currentIteration > maxIterations) {\r",
									"    console.log('All deletion attempts completed');\r",
									"    pm.execution.setNextRequest(null);\r",
									"    return;\r",
									"}\r",
									"\r",
									"const currentProjectKey = projectsToDelete[currentIteration - 1];\r",
									"pm.environment.set('currentProjectKey', currentProjectKey);\r",
									"pm.environment.set('totalProjectsToDelete', maxIterations);\r",
									"\r",
									"console.log(`Deleting ${currentIteration}/${maxIterations}: ${currentProjectKey}`);"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"const currentIteration = parseInt(pm.environment.get('delete_iteration') || '1');\r",
									"const maxIterations = parseInt(pm.environment.get('totalProjectsToDelete'));\r",
									"\r",
									"// Loop control\r",
									"if (currentIteration < maxIterations) {\r",
									"    pm.environment.set('delete_iteration', (currentIteration + 1).toString());\r",
									"    pm.execution.setNextRequest(pm.info.requestName);\r",
									"} else {\r",
									"    // Simple final test\r",
									"    pm.test('Project deletion process completed', function () {\r",
									"        pm.expect([204, 404]).to.include(pm.response.code);\r",
									"        pm.expect(pm.response.responseTime).to.be.below(5000);\r",
									"    });\r",
									"    \r",
									"    pm.environment.unset('delete_iteration');\r",
									"    pm.environment.unset('totalProjectsToDelete');\r",
									"    console.log('All project deletions completed');\r",
									"}"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{jiraBaseUrl}}/project/{{currentProjectKey}}",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"project",
								"{{currentProjectKey}}"
							]
						}
					},
					"response": []
				},
				{
					"name": "Final Environment Cleanup",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"const keepVars = [\r",
									"    'jiraBaseUrl',\r",
									"    'jiraEmail', \r",
									"    'jiraApiToken'\r",
									"];\r",
									"\r",
									"const allVarNames = Object.keys(pm.environment.toObject());\r",
									"const varsToDelete = allVarNames.filter(varName => \r",
									"    !keepVars.includes(varName)\r",
									");\r",
									"\r",
									"console.log(`Deleting ${varsToDelete.length} variables, keeping ${keepVars.length} config variables`);\r",
									"varsToDelete.forEach(varName => pm.environment.unset(varName));"
								],
								"type": "text/javascript",
								"packages": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Final environment cleanup - minimal config preserved', function () {\r",
									"    pm.response.to.have.status(200);\r",
									"    \r",
									"    const remainingVars = Object.keys(pm.environment.toObject());\r",
									"    const expectedVars = ['jiraBaseUrl', 'jiraEmail', 'jiraApiToken'];\r",
									"    \r",
									"    pm.expect(remainingVars.length).to.eql(3, `Expected 3 variables, found ${remainingVars.length}: ${remainingVars.join(', ')}`);\r",
									"    \r",
									"    expectedVars.forEach(varName => {\r",
									"        const value = pm.environment.get(varName);\r",
									"        pm.expect(value, `Missing required variable: ${varName}`).to.not.be.null;\r",
									"        pm.expect(value, `Empty value for: ${varName}`).to.not.be.empty;\r",
									"    });\r",
									"    \r",
									"    remainingVars.forEach(varName => {\r",
									"        pm.expect(expectedVars, `Unexpected variable found: ${varName}`).to.include(varName);\r",
									"    });\r",
									"    \r",
									"    console.log('Environment cleaned to minimal config: jiraBaseUrl, jiraEmail, jiraApiToken');\r",
									"});"
								],
								"type": "text/javascript",
								"packages": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{jiraBaseUrl}}/myself",
							"host": [
								"{{jiraBaseUrl}}"
							],
							"path": [
								"myself"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"auth": {
		"type": "basic",
		"basic": [
			{
				"key": "password",
				"value": "{{jiraApiToken}}",
				"type": "string"
			},
			{
				"key": "username",
				"value": "{{jiraEmail}}",
				"type": "string"
			}
		]
	},
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"exec": [
					""
				]
			}
		}
	]
}